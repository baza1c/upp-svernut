
&НаСервере
Перем МодульОбъекта;

&НаКлиенте
Перем МодульОбъектаКлиент;

&НаКлиенте
Перем СоединениеДД;
  
&НаКлиенте
Перем мРабочийКаталог;

&НаКлиенте
Перем HttpКодыВозвратаAPI;

&НаКлиенте
Перем ХранилищеСертификатов1С;

&НаКлиенте
Перем КэшСертификатов;

&НаКлиенте
Перем Токены;

// СЛУЖЕБНЫЕ {

// Инициализация модуля и его экспортных функций
&НаСервере
Функция МодульОбъекта()
	
	Если МодульОбъекта = Неопределено Тогда
		
		Если Объект.ПараметрыКлиентСервер.КэшироватьОбработкуОбъект Тогда
			МодульОбъекта = МодульОбъектаИзКэша();
		КонецЕсли;
		
		Если МодульОбъекта = Неопределено Тогда
			МодульОбъекта = РеквизитФормыВЗначение("Объект");
			МодульОбъекта.ИнициализироватьПодключаемыеМодули(); // TODO Проверить что из этого используется на формах и перенести в ПараметрыКлиентСервер
			МодульОбъекта.ОбновитьКэшМодуляОбъекта();
		КонецЕсли;
		
	КонецЕсли;	
	
	Возврат МодульОбъекта;
	
КонецФункции

&НаСервере
Функция МодульОбъектаИзКэша()
	
	Результат = Неопределено;
	
	Если ТипЗнч(Объект.ПараметрыКлиентСервер) = Тип("Структура") Тогда
		АдресВХ = Объект.ПараметрыКлиентСервер.АдресаВХ.ОбработкаОбъект;
 		Если ЭтоАдресВременногоХранилища(АдресВХ) Тогда
			Структура = ПолучитьИзВременногоХранилища(АдресВХ);
			Если ТипЗнч(Структура) = Тип("Структура") и Структура.Свойство("ОбработкаОбъект") Тогда
			 	Результат = Структура.ОбработкаОбъект;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Функция МодульОбъектаКлиент()
	
	Если ТипЗнч(МодульОбъектаКлиент) = Тип("УправляемаяФорма") Тогда
		Возврат МодульОбъектаКлиент;
	КонецЕсли;
	
	ОсновнаяФорма = ОсновнаяФорма();
	Если ТипЗнч(ОсновнаяФорма) = Тип("УправляемаяФорма") Тогда
		МодульОбъектаКлиент = ОсновнаяФорма.МодульОбъектаКлиент();
		Возврат МодульОбъектаКлиент;
	Иначе
		Сообщить("Ошибка! Не удалось получить контекст основной формы.");
	КонецЕсли;
	          	
КонецФункции

&НаКлиенте
Функция ОсновнаяФорма() Экспорт
	
	Если ЭтаФорма.ВладелецФормы = Неопределено Тогда
		Возврат Неопределено;
	Иначе
		Возврат ЭтаФорма.ВладелецФормы.ОсновнаяФорма();
	КонецЕсли;
    	
КонецФункции

&НаКлиенте
Функция НоваяМетрика()
	
	Возврат ОсновнаяФорма().НоваяМетрика();
	
КонецФункции

&НаКлиенте
Функция МодульОбменКлиент()
	
	Возврат ЭтаФорма;
	
КонецФункции

&НаКлиенте
Процедура ПоместитьВоВХ(Имя,Значение)
	
	ПоместитьВоВременноеХранилище(Значение, Объект.ПараметрыКлиентСервер.АдресаВХ[Имя]);
				
КонецПроцедуры

&НаКлиенте
Функция ИзвлечьИзВХ(Имя)
	
	АдресВХ = Объект.ПараметрыКлиентСервер.АдресаВХ[Имя];
	
	Если Не ЭтоАдресВременногоХранилища(АдресВХ) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат ПолучитьИзВременногоХранилища(АдресВХ);
			
КонецФункции

// } СЛУЖЕБНЫЕ

&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	
	Параметры.Свойство("ОбъектПараметрыКлиентСервер", 			Объект.ПараметрыКлиентСервер);
	Параметры.Свойство("ОбъектПараметрыКлиентСерверМетрика", 	Объект.ПараметрыКлиентСерверМетрика);
	
	ИспользоватьCapicom = (МодульОбъекта().ПолучитьКонстантуEDI("ИспользоватьCapicom") = Истина);
	
	ЗаполнитьТаблицуАвторизацииПоУмолчанию();
	
КонецПроцедуры

&НаКлиенте
Процедура ПриОткрытии(Отказ)
	
	//Форма не предусмотрена для интерактивного показа пользователю
	Этаформа.Закрыть();
	
КонецПроцедуры

&НаКлиенте
Процедура ПодписатьПереданныеСообщения() Экспорт //переданные в ВХ 
	
	СформироватьСчетаФактурыНаПодписание();
	СброситьПроверкиДанныхАвторизации();
	СпроситьНедостающиеСертификатыДляПодписиИПодписатьСчетаФактуры();
	
КонецПроцедуры


// Для перехода на версию 4.03.019.01

&НаКлиенте
Процедура ПроставитьСрокДействияСертификатов() Экспорт

	МассивСертификатовДляОбновления = ПолучитьМассивСертификатовДляОбновленияСервер();
	
	Для каждого Сертификат Из МассивСертификатовДляОбновления Цикл
		РеквизитыСертификата = ПолучитьРеквизитыСертификата(Сертификат.Отпечаток);
		
		Если РеквизитыСертификата = Неопределено Тогда
			// Не смогли прочитать реквизиты, попробуем в другой раз
			Возврат;
		КонецЕсли;
		Сертификат.СертификатДействуетПо = РеквизитыСертификата.ОкончаниеПериодаДействия;
	КонецЦикла;
	
	СохранитьСрокДействияСертификатовСервер(МассивСертификатовДляОбновления);

КонецПроцедуры

&НаСервере
Функция ПолучитьМассивСертификатовДляОбновленияСервер()

	МассивСертификатовДляОбновления = Новый Массив;
	
	ВсеСохраненныеСертификаты = МодульОбъекта().ПолучитьТаблицуСохраненныхСертификатов();
	НайденныеСтроки = ВсеСохраненныеСертификаты.НайтиСтроки(Новый Структура("СертификатДействуетПо", Дата(1, 1, 1)));
	
	Для каждого Строка Из НайденныеСтроки Цикл
		
		СертификатСтруктура = Новый Структура("Ссылка, Отпечаток, СертификатДействуетПо", 
												Строка.Ссылка, 
												Строка.Отпечаток,
												Строка.СертификатДействуетПо);
		МассивСертификатовДляОбновления.Добавить(СертификатСтруктура);
	
	КонецЦикла;
	
	Возврат МассивСертификатовДляОбновления;

КонецФункции // ПолучитьМассивСертификатовДляСохраненияСервер()

&НаСервере
Процедура СохранитьСрокДействияСертификатовСервер(МассивСертификатовДляОбновления)

	Для каждого Сертификат Из МассивСертификатовДляОбновления Цикл
	
		МодульОбъекта().ЗаписатьДопРеквизитСправочника_КонтурEDI(Сертификат.Ссылка, "СертификатДействуетПо", Сертификат.СертификатДействуетПо);
	
	КонецЦикла;

	МодульОбъекта().УстановитьКонстантуEDI("СрокДействияСертификатовПроставлен", Истина);

КонецПроцедуры

// Для перехода на версию 4.03.019.01


//Вспомогательные
&НаСервере
Процедура СформироватьСчетаФактурыНаПодписание()
	
	//соберем идентификаторы СФ которые будем подписывать
	СчетаФактурыНаПодписание.Загрузить(МодульОбъекта().ПолучитьТаблицуСчетовФактурНаПодписание(МодульОбъекта().ИзвлечьИзВХ("Диадок_МассивСообщенийДляПодписания")));
	ЗаполнитьТаблицуАвторизацииПоУмолчанию();

КонецПроцедуры

&НаКлиенте
Процедура СпроситьНедостающиеСертификатыДляПодписиИПодписатьСчетаФактуры() //возможен неоднократный вызов для простановки сертифткатов
	
	ТекОрганизация = Неопределено;

	Для Каждого СтрокаСЧФ Из СчетаФактурыНаПодписание Цикл // СчетаФактурыНаПодписание отсортированы по Организации в методе ПолучитьТаблицуСчетовФактурНаПодписание
		
		Если ТекОрганизация <> СтрокаСЧФ.Организация Тогда
			
			ТекОрганизация = СтрокаСЧФ.Организация;
			ИнициализироватьДанныеАвторизации(ТекОрганизация);
			ОбновитьДанныеАвторизации("ТипАвторизации", "Сертификат"); 
			
			Если ПропускСертификатаПоОрганизации(ТекОрганизация) Тогда
				// по какой-то причине не удалось выбрать сертификат или не прошли проверку с сертификатом
				Продолжить; 
			КонецЕсли;
			
			Если НЕ МожемПодписатьДокументыСертификатом(ТекОрганизация, ДанныеАвторизации, "СпроситьНедостающиеСертификатыДляПодписиИПодписатьСчетаФактуры()") Тогда
				Возврат;
			КонецЕсли;
			
		КонецЕсли;
	КонецЦикла;
	
	// Все сертификаты выбраны (или не выбраны, если пользователь отказался выбирать)
	
	ПодписатьСчетаФактуры();
	СброситьПарольКонтейнераДанныхАвторизации();
	
КонецПроцедуры

&НаКлиенте
Функция МожемПодписатьДокументыСертификатом(Организация, ДанныеАвторизации, ФинальныйОбработчик)
	
	Если НЕ СертификатПоОрганизацииНазначен(Организация) Тогда 
		
		ПараметрыФормы = Новый Структура;
		ПараметрыФормы.Вставить("ОбъектПараметрыКлиентСервер", Объект.ПараметрыКлиентСервер);
		ПараметрыФормы.Вставить("Организация", Организация);
		ПараметрыФормы.Вставить("ПоказыватьФлагЗапомнитьВыбор", Истина);
		
		ДопПараметры = Новый Структура;
		ДопПараметры.Вставить("Действие", 				"ВыборСертификата");
		ДопПараметры.Вставить("Организация", 			Организация);
		ДопПараметры.Вставить("Отпечаток",   			"");
		ДопПараметры.Вставить("СертификатДействуетПо",  Дата(1, 1, 1));
		ДопПараметры.Вставить("ЗапомнитьВыбор", 		Ложь);
		ДопПараметры.Вставить("НомерПопытки", 			1);
		ДопПараметры.Вставить("Успешно", 				Ложь);
		ДопПараметры.Вставить("ОписаниеОшибки", 		"");
		ДопПараметры.Вставить("ФинальныйОбработчик", 	ФинальныйОбработчик);
		
		МодульОбъектаКлиент().ОткрытьФорму_КонтурEDI("Сертификаты_СписокУправляемая", , ПараметрыФормы, ЭтаФорма, "ОбработчикВыбораСертификата", ЭтаФорма, ДопПараметры);
		
		Возврат Ложь; //не готовы подписывать, сначала надо выбрать сертификат
		
	ИначеЕсли ДанныеАвторизации.СертификатПроверен = Ложь Тогда
		
		ДопПараметры = Новый Структура;
		ДопПараметры.Вставить("Действие",	 			"ПроверкаПодписания");
		ДопПараметры.Вставить("Организация", 			ДанныеАвторизации.Организация);
		ДопПараметры.Вставить("Отпечаток",   			ДанныеАвторизации.Отпечаток);
		ДопПараметры.Вставить("СертификатДействуетПо",  ДанныеАвторизации.СертификатДействуетПо);
		ДопПараметры.Вставить("ЗапомнитьВыбор", 		Ложь);
		ДопПараметры.Вставить("НомерПопытки", 			1);
		ДопПараметры.Вставить("Успешно", 				Ложь);
		ДопПараметры.Вставить("ОписаниеОшибки", 		"");
		ДопПараметры.Вставить("ФинальныйОбработчик", 	ФинальныйОбработчик);
		
		ОбработчикВыбораСертификата(ДанныеАвторизации.ПарольКонтейнера, ДопПараметры);
		
		Возврат Ложь; //не готовы подписывать, сначала надо проверить сертификат
		
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

&НаКлиенте
Процедура ОбработчикВыбораСертификата(ВыбранноеЗначение, ДопПараметры) Экспорт
	
	Если ДопПараметры.Действие = "ВыборСертификата" Тогда
		
		Если ВыбранноеЗначение = Неопределено Тогда
		
			// пользователь отказался от выбора сертификата
			ОбновитьДанныеАвторизации("СертификатПроверен", 			Истина);
			ОбновитьДанныеАвторизации("ВалидацияСертификатаПройдена", 	Ложь);
			ДопПараметры.Вставить("ОписаниеОшибки", "Выбор сертификата отменен");
			ВыполнитьКомандуФинальногоОбработчикаВыбораСертификата(ДопПараметры.ФинальныйОбработчик, ДопПараметры);
			
		Иначе
			
			ИнициализироватьДанныеАвторизации(ВыбранноеЗначение.Организация);
			СброситьДанныеАвторизацииСертификата();
			
			ОбновитьДанныеАвторизации("ТипАвторизации", "Сертификат"); 
			
			ДопПараметры.Вставить("Действие",				"ПроверкаПодписания");
			ДопПараметры.Вставить("Организация",  			ВыбранноеЗначение.Организация);
			ДопПараметры.Вставить("Отпечаток",  			ВыбранноеЗначение.Отпечаток);
			ДопПараметры.Вставить("СертификатДействуетПо",  ВыбранноеЗначение.СертификатДействуетПо);
			ДопПараметры.Вставить("ЗапомнитьВыбор", 		ВыбранноеЗначение.ЗапомнитьВыбор);
			ДопПараметры.Вставить("НомерПопытки", 			1);
			ДопПараметры.Вставить("Успешно", 				Ложь);
			ДопПараметры.Вставить("ОписаниеОшибки", 		"");
			ДопПараметры.Вставить("РеквизитыСертификата", 	ВыбранноеЗначение.РеквизитыСертификата);
		
			ОбработчикВыбораСертификата(ДанныеАвторизации.ПарольКонтейнера, ДопПараметры);
			
			Возврат;
			
		КонецЕсли;
		
	ИначеЕсли ДопПараметры.Действие = "ПроверкаПодписания" Тогда
		
		Если ВыбранноеЗначение = Неопределено Тогда
			
			// пользователь отказался от выбора сертификата
			ОбновитьДанныеАвторизации("СертификатПроверен", 			Истина);
			ОбновитьДанныеАвторизации("ВалидацияСертификатаПройдена", 	Ложь);
			ДопПараметры.Вставить("ОписаниеОшибки", "Ввод пароля отменен");
			ВыполнитьКомандуФинальногоОбработчикаВыбораСертификата(ДопПараметры.ФинальныйОбработчик, ДопПараметры);
			
		Иначе
			
			ОбработчикПроверкиПодписанияСертификатом(ВыбранноеЗначение, ДопПараметры);
			
			Возврат;
			
		КонецЕсли;
		
	ИначеЕсли ДопПараметры.Действие = "ПовторныйВыборСертификата" Тогда
		
		// выбор сертификата завершился ошибкой, предложим выбрать еще раз
		ПараметрыФормы = Новый Структура;
		ПараметрыФормы.Вставить("ОбъектПараметрыКлиентСервер", 	Объект.ПараметрыКлиентСервер);
		ПараметрыФормы.Вставить("Организация", 					ДопПараметры.Организация);
		Если Найти(ДопПараметры.ФинальныйОбработчик, "СпроситьНедостающиеСертификатыДляПодписиИПодписатьСчетаФактуры()") > 0 Тогда
			ПараметрыФормы.Вставить("ПоказыватьФлагЗапомнитьВыбор", Истина);
		КонецЕсли;
		
		ДопПараметры.Вставить("Действие", 				"ВыборСертификата");
		ДопПараметры.Вставить("НомерПопытки", 			1);
		
		МодульОбъектаКлиент().ОткрытьФорму_КонтурEDI("Сертификаты_СписокУправляемая", , ПараметрыФормы, ЭтаФорма, "ОбработчикВыбораСертификата", ЭтаФорма, ДопПараметры);
		
		Возврат;

	ИначеЕсли ДопПараметры.Действие = "ЗавершениеПроверки" Тогда
		
		ВыполнитьКомандуФинальногоОбработчикаВыбораСертификата(ДопПараметры.ФинальныйОбработчик, ДопПараметры);
		
	КонецЕсли;
		
КонецПроцедуры

&НаКлиенте
Процедура ВыполнитьКомандуФинальногоОбработчикаВыбораСертификата(ТекстКоманды, ДопПараметры)
	
	Если Найти(ТекстКоманды, "Оповестить_") > 0 Тогда
		ИмяСобытия = Сред(ТекстКоманды, 12);
		Оповестить(ИмяСобытия, ДопПараметры);
	Иначе
		Если ДопПараметры.Успешно = Ложь Тогда
			МодульОбъектаКлиент().СообщениеПользователю_КонтурEDI(ДопПараметры.ОписаниеОшибки);
		КонецЕсли;
		
		Выполнить(ТекстКоманды);
	КонецЕсли;
	
КонецПроцедуры

&НаСервере
Процедура СохранитьСертификатПоУмолчаниюСервер(ДанныеСертификата)

	МодульОбъекта().СохранитьСертификатПоУмолчанию(ДанныеСертификата);
	
КонецПроцедуры 

&НаКлиенте
Процедура ОбработчикПроверкиПодписанияСертификатом(ВыбранноеЗначение, ДопПараметры) Экспорт
	
	Состояние("Проверка сертификата...");
	
	ПарольКонтейнера = "";
	СохранитьПароль = Ложь;
	
	Если ТипЗнч(ВыбранноеЗначение) = Тип("Структура") Тогда
		ПарольКонтейнера = ВыбранноеЗначение.ПолеВвода;
		СохранитьПароль = ВыбранноеЗначение.Флаг;
	ИначеЕсли ТипЗнч(ВыбранноеЗначение) = Тип("Строка") Тогда
		ПарольКонтейнера = ВыбранноеЗначение;
	КонецЕсли;
		
	РезультатПроверки = ПроверитьВыбранныйСертификат(ДопПараметры.Организация, ДопПараметры.Отпечаток, ДопПараметры.СертификатДействуетПо, ПарольКонтейнера);
	
	Если НЕ ИспользоватьCapicom
		И РезультатПроверки.Успешно = Ложь
		И ОшибкаНеправильныйПарольКонтейнера(РезультатПроверки.ОписаниеОшибки)
		И ДопПараметры.НомерПопытки = 1 Тогда
		
		ПарольКонтейнера = ПолучитьПарольКонтейнераСертификатаСервер(ДопПараметры.Организация, ДопПараметры.Отпечаток);
		РезультатПроверки = ПроверитьВыбранныйСертификат(ДопПараметры.Организация, ДопПараметры.Отпечаток, ДопПараметры.СертификатДействуетПо, ПарольКонтейнера);
		
	КонецЕсли;
		
	ОбновитьДанныеАвторизации("СертификатПроверен", Истина);
	
	Если РезультатПроверки.Успешно = Истина Тогда
		
		ДопПараметры.Успешно = Истина;
		ОбновитьДанныеАвторизации("ВалидацияСертификатаПройдена", 	Истина);
		ОбновитьДанныеАвторизации("ПарольКонтейнера", 				ПарольКонтейнера);
		
		Если Не ЗначениеЗаполнено(ДанныеАвторизации.Отпечаток) Тогда
			// могли только что выбрать сертификат через форму
			ОбновитьДанныеАвторизации("Отпечаток", 				ДопПараметры.Отпечаток); 
			ОбновитьДанныеАвторизации("СертификатДействуетПо", 	ДопПараметры.СертификатДействуетПо);
		КонецЕсли;
		
		Если ДопПараметры.ЗапомнитьВыбор = Истина Тогда
			
			ДанныеСертификата = Новый Структура;
			ДанныеСертификата.Вставить("Организация", 			ДопПараметры.Организация);
			ДанныеСертификата.Вставить("Отпечаток", 			ДопПараметры.Отпечаток);
			ДанныеСертификата.Вставить("СертификатДействуетПо", ДопПараметры.СертификатДействуетПо);
			
			СохранитьСертификатПоУмолчаниюСервер(ДанныеСертификата);
			
		КонецЕсли;
		
		Если СохранитьПароль = Истина Тогда
			
			ДанныеСертификата = Новый Структура;
			ДанныеСертификата.Вставить("Организация", 			ДопПараметры.Организация);
			ДанныеСертификата.Вставить("Отпечаток", 			ДопПараметры.Отпечаток);
			ДанныеСертификата.Вставить("СертификатДействуетПо", ДопПараметры.СертификатДействуетПо);
			ДанныеСертификата.Вставить("ПарольКонтейнера", 		ПарольКонтейнера);
			
			СохранитьПараметрыСертификатаСервер(ДанныеСертификата);
			
		КонецЕсли;											
		
	Иначе
		
		ОбновитьДанныеАвторизации("ВалидацияСертификатаПройдена", Ложь);
		ДопПараметры.ОписаниеОшибки = РезультатПроверки.ОписаниеОшибки;
		
		Если ЗначениеЗаполнено(ДопПараметры.СертификатДействуетПо) 
			И КонецДня(ДопПараметры.СертификатДействуетПо) < ТекущаяДата() Тогда
			ДопПараметры.ОписаниеОшибки = "Истек срок действия сертификата." + Символы.ПС + ДопПараметры.ОписаниеОшибки;				
		КонецЕсли;
		
		Если НЕ ИспользоватьCapicom
			И ОшибкаНеправильныйПарольКонтейнера(РезультатПроверки.ОписаниеОшибки) Тогда
			СпроситьПарольКонтейнера(ДопПараметры);
			Возврат;
		КонецЕсли;
	
	КонецЕсли;
	
	Если Найти(РезультатПроверки.ОписаниеОшибки, "ГОСТ 2001") <> 0
		И РезультатПроверки.Успешно = Ложь Тогда
		
		ЗадатьВопросПроСертификатПоГОСТ2001(РезультатПроверки.ОписаниеОшибки, ВыбранноеЗначение, ДопПараметры);
		Возврат;
		
	КонецЕсли;
	
	Если РезультатПроверки.Успешно = Ложь
		И Не СертификатПоОрганизацииНазначен(ДопПараметры.Организация) Тогда
		
		ДопПараметры.Вставить("Действие",	"ПовторныйВыборСертификата");
		МодульОбъектаКлиент().СообщениеПользователю_КонтурEDI(ДопПараметры.ОписаниеОшибки);
		
	Иначе
		ДопПараметры.Вставить("Действие",	"ЗавершениеПроверки");
	КонецЕсли;
	
	ОбработчикВыбораСертификата(ВыбранноеЗначение, ДопПараметры);
	
КонецПроцедуры

&НаКлиенте
Процедура ЗадатьВопросПроСертификатПоГОСТ2001(ТекстВопроса, ВыбранноеЗначение, ДопПараметры)
	
	ИмяОбработчика = "ОбработчикОтветаНаВопросПроСертификатПоГОСТ2001";
	КонтекстОбработчика = ЭтаФорма;
	
	КнопкиВопроса = Новый СписокЗначений;
	КнопкиВопроса.Добавить("Выбрать сертификат");
	КнопкиВопроса.Добавить("Подать заявку на выпуск");
	
	КнопкаПоУмолчанию = "Выбрать сертификат";
	
	ДопПараметры.Вставить("ВыбранноеЗначение", ВыбранноеЗначение);
	
	Если ТекущаяДата() < Дата(2020, 1, 1) Тогда
		КнопкиВопроса.Добавить("Я уже знаю что делать, продолжить работу до конца 2019 года");
	КонецЕсли;
	
	МодульОбъектаКлиент().ПоказатьВопрос_КонтурEDI("ОбработчикОтветаНаВопросПроСертификатПоГОСТ2001", ЭтаФорма, ДопПараметры, ТекстВопроса, КнопкиВопроса, , КнопкаПоУмолчанию);
	
КонецПроцедуры
								
&НаКлиенте
Процедура ОбработчикОтветаНаВопросПроСертификатПоГОСТ2001(ВыбранноеЗначение, ДопПараметры) Экспорт
	
	НоваяМетрика().НаФорме(ЭтаФорма).Категория("ГОСТ2001").Выбор(ВыбранноеЗначение).ПоместитьВОчередь();
	
	Если ВыбранноеЗначение = "Выбрать сертификат" Тогда
		ДопПараметры.Вставить("Действие", "ПовторныйВыборСертификата");
		ОбработчикВыбораСертификата(ДопПараметры.ВыбранноеЗначение, ДопПараметры);
	КонецЕсли;	
		
	Если ВыбранноеЗначение = "Подать заявку на выпуск" Тогда
		ЗапуститьПриложение(Объект.ПараметрыКлиентСервер.URLАдреса.СтраницаКонтурУЦПодатьЗаявкуНаСертификат);
		ДопПараметры.Вставить("Действие", "ЗавершениеПроверки");
		ОбработчикВыбораСертификата(ДопПараметры.ВыбранноеЗначение, ДопПараметры);
	КонецЕсли;	
		
	Если ВыбранноеЗначение = "Я уже знаю что делать, продолжить работу до конца 2019 года" Тогда
		УстановитьОтметкуУведомленияОСертификатеПоГОСТ2001Сервер(ДопПараметры);
		ДопПараметры.Вставить("Действие", "ПроверкаПодписания");
		ОбработчикВыбораСертификата(ДопПараметры.ВыбранноеЗначение, ДопПараметры);
	КонецЕсли;	
	
КонецПроцедуры

&НаСервере
Процедура УстановитьОтметкуУведомленияОСертификатеПоГОСТ2001Сервер(ДопПараметры)
	
	МодульОбъекта().УстановитьОтметкуУведомленияОСертификатеПоГОСТ2001(ДопПараметры);
	
КонецПроцедуры

&НаКлиенте
Функция ОбработкаИсключенияТипМодуляКриптографии(ОписаниеОшибки, ДанныеСертификата)
	
	ОписаниеОшибкиНРег = НРег(ОписаниеОшибки);
	
	Если Найти(ОписаниеОшибкиНРег, НРег("Сертификат, связанный с закрытым ключом, указывает на модуль криптографии, отличный от текущего.")) = 0 Тогда
		Возврат Ложь;	
	КонецЕсли;
	
	Для Каждого МодульКриптографии Из ПолучитьТипыМодуляКриптографии() Цикл
		
		Если Найти(ОписаниеОшибкиНРег, НРег(МодульКриптографии.ИмяМодуляКриптографии)) <> 0
			И Найти(ОписаниеОшибкиНРег, НРег(МодульКриптографии.ТипМодуляКриптографии)) <> 0 Тогда
			
			ОбновитьДанныеАвторизации("ИмяМодуляКриптографии", МодульКриптографии.ИмяМодуляКриптографии);
			ОбновитьДанныеАвторизации("ТипМодуляКриптографии", МодульКриптографии.ТипМодуляКриптографии);
			
			ДанныеСертификата.Вставить("ИмяМодуляКриптографии", МодульКриптографии.ИмяМодуляКриптографии);
			ДанныеСертификата.Вставить("ТипМодуляКриптографии", МодульКриптографии.ТипМодуляКриптографии);
			
			СохранитьПараметрыСертификатаСервер(ДанныеСертификата);
			
			Возврат Истина;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

&НаКлиенте
Функция ОшибкаНеправильныйПарольКонтейнера(ОписаниеОшибки = "")

	Если Найти(Нрег(ОписаниеОшибки), "неправильный пароль доступа к закрытому ключу") <> 0
		ИЛИ Найти(Нрег(ОписаниеОшибки), "контекст был получен в ограниченном режиме") <> 0 Тогда
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;

КонецФункции // ОшибкаНеправильныйПарольКонтейнера()

&НаКлиенте
Функция ПолучитьТекстСообщенияДляВопросаОПароле(Отпечаток)

	РеквизитыСертификата = ПолучитьРеквизитыСертификата(Отпечаток);
	
	// Подготовка заголовка и текста вопроса
	НаименованиеОрганизации = "";
	Если ЗначениеЗаполнено(РеквизитыСертификата.НаименованиеОрганизацииСубъекта) Тогда
		НаименованиеОрганизации = РеквизитыСертификата.НаименованиеОрганизацииСубъекта;
	ИначеЕсли ЗначениеЗаполнено(РеквизитыСертификата.НаименованиеСубъекта) Тогда
		НаименованиеОрганизации = РеквизитыСертификата.НаименованиеСубъекта;
	Иначе
		НаименованиеОрганизации = "<Не указано>";
	КонецЕсли;
	
	НаименованиеСубъекта = "";
	НаименованиеСубъекта = РеквизитыСертификата.НаименованиеСубъекта;
	Если НаименованиеСубъекта = НаименованиеОрганизации Тогда
		НаименованиеСубъекта = "";
	КонецЕсли;
	ОкончаниеПериодаДействия = Формат(РеквизитыСертификата.ОкончаниеПериодаДействия, "ДЛФ=Д");
	
	ТекстСообщения1 = НаименованиеОрганизации + Символы.ПС + ?(НаименованиеСубъекта = "", "", НаименованиеСубъекта + Символы.ПС ) 
						+ "Годен до " + ОкончаниеПериодаДействия;
						
	Возврат ТекстСообщения1;

КонецФункции // ()

&НаКлиенте
Процедура СпроситьПарольКонтейнера(ДопПараметры)
	
	// Подготовка параметров для заполнения универсальной формы ввода
	ПроизвольныеПараметры = Новый Структура;
	ПроизвольныеПараметры.Вставить("ТекстСообщения1", 		ПолучитьТекстСообщенияДляВопросаОПароле(ДопПараметры.Отпечаток));
	ПроизвольныеПараметры.Вставить("ЗаголовокФормы", 		"Введите пароль");
	ПроизвольныеПараметры.Вставить("ФлагЗаголовок",			"Запомнить пароль");
	ПроизвольныеПараметры.Вставить("ФлагВидимость", 		Истина);
	ПроизвольныеПараметры.Вставить("ТекстСообщения1Цвет", 	Неопределено);
	ПроизвольныеПараметры.Вставить("ПолеВводаРежимПароля", 	Истина);
	
	Если ДопПараметры.НомерПопытки > 1 Тогда
		ТекстСообщения2 = "Неправильный пароль";
		ПроизвольныеПараметры.Вставить("ТекстСообщения2", 		ТекстСообщения2);
		ПроизвольныеПараметры.Вставить("ТекстСообщения2Цвет", 	WebЦвета.Красный);
	КонецЕсли;
	
	ПараметрыФормы = Новый Структура;
	ПараметрыФормы.Вставить("ПроизвольныеПараметры", ПроизвольныеПараметры);
	
	ДопПараметры.НомерПопытки = ДопПараметры.НомерПопытки + 1;
	
	МодульОбъектаКлиент().ОткрытьФорму_КонтурEDI("УниверсальнаяФормаВводаУправляемая", , ПараметрыФормы, ЭтаФорма, "ОбработчикВыбораСертификата", ЭтаФорма, ДопПараметры);
	
КонецПроцедуры

&НаКлиенте
Функция СертификатПоОрганизацииНазначен(Организация)

	Если ТаблицаАвторизации.Количество() = 0 Тогда 
		ЗаполнитьТаблицуАвторизацииПоУмолчанию();
	КонецЕсли;
	
	НайденныеСтроки = ТаблицаАвторизации.НайтиСтроки(Новый Структура("Организация",Организация));
	Если НайденныеСтроки.Количество() = 1
		И ЗначениеЗаполнено(НайденныеСТроки[0].Отпечаток) Тогда 
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
		
КонецФункции

&НаКлиенте
Функция ПолучитьНазначенныйОрганизацииСертификат(Организация)
	
	НайденныеСтроки = ТаблицаАвторизации.НайтиСтроки(Новый Структура("Организация",Организация));
	Если НайденныеСтроки.Количество() = 1
		И ЗначениеЗаполнено(НайденныеСтроки[0].Отпечаток) Тогда 
		Возврат НайденныеСтроки[0].Отпечаток;
	Иначе
		Возврат "";
	КонецЕсли;
	
КонецФункции

&НаКлиенте
Процедура ИнициализироватьДанныеАвторизации(Организация)
	
	ДанныеАвторизации = ПолучитьСтруктуруДанныхАвторизации();
	
	Если ТаблицаАвторизации.Количество() = 0 Тогда 
		ЗаполнитьТаблицуАвторизацииПоУмолчанию();
	КонецЕсли;
	
	НайденныеСтроки = ТаблицаАвторизации.НайтиСтроки(Новый Структура("Организация",Организация));
	
	Если НайденныеСтроки.Количество() = 1 Тогда
		ЗаполнитьЗначенияСвойств(ДанныеАвторизации, НайденныеСтроки[0]);
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Процедура СброситьДанныеАвторизацииСертификата()
	
	СтруктураДанныхАвторизации = ПолучитьСтруктуруДанныхАвторизации();
	
	СписокСвойств = "Отпечаток,СертификатПроверен,СертификатДействуетПо," + 
		"ВалидацияСертификатаПройдена,ПарольКонтейнера,ТипМодуляКриптографии,ИмяМодуляКриптографии";
	ЗаполнитьЗначенияСвойств(ДанныеАвторизации, СтруктураДанныхАвторизации, СписокСвойств);
	
КонецПроцедуры

&НаКлиенте
Функция ПолучитьСтруктуруДанныхАвторизации()
	
	СтруктураДанныхАвторизации = Новый Структура;
	СтруктураДанныхАвторизации.Вставить("Организация", 						Неопределено);
	СтруктураДанныхАвторизации.Вставить("Отпечаток", 						"");
	СтруктураДанныхАвторизации.Вставить("ЛогинДД", 							"");
	СтруктураДанныхАвторизации.Вставить("ПарольДД", 						"");
	СтруктураДанныхАвторизации.Вставить("ЛогинПарольДДПроверен", 			Ложь);
	СтруктураДанныхАвторизации.Вставить("СертификатПроверен", 				Ложь);
	СтруктураДанныхАвторизации.Вставить("СертификатДействуетПо", 			Дата(1, 1, 1));
	СтруктураДанныхАвторизации.Вставить("ВалидацияЛогинаПароляДДПройдена", 	Ложь);
	СтруктураДанныхАвторизации.Вставить("ВалидацияСертификатаПройдена", 	Ложь);
	СтруктураДанныхАвторизации.Вставить("ПарольКонтейнера", 				"");
	СтруктураДанныхАвторизации.Вставить("ТипАвторизации", 					"");
	СтруктураДанныхАвторизации.Вставить("ТипМодуляКриптографии",			0);
	СтруктураДанныхАвторизации.Вставить("ИмяМодуляКриптографии", 			"");

	Возврат СтруктураДанныхАвторизации;
	
КонецФункции

&НаКлиенте
Процедура ОбновитьДанныеАвторизации(Ключ, Значение)
	
	Если ДанныеАвторизации = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	// Обновим данные в структуре ДанныеАвторизации на форме
	ДанныеАвторизации[Ключ] = Значение;
	
	// Обновим данные в таблице ТаблицаАвторизации на форме
	НайденныеСтроки = ТаблицаАвторизации.НайтиСтроки(Новый Структура("Организация", ДанныеАвторизации.Организация));
	Если НайденныеСтроки.Количество() = 1 Тогда
		ЗаполнитьЗначенияСвойств(НайденныеСтроки[0], ДанныеАвторизации);
	КонецЕсли;

КонецПроцедуры

&НаКлиенте
Функция ПропускСертификатаПоОрганизации(Организация)
	
	Если НЕ ЗначениеЗаполнено(Организация) Тогда
		// не знаем данные авторизации
		Возврат Истина;
	КонецЕсли;
	
	НайденныеСтроки = ТаблицаАвторизации.НайтиСтроки(Новый Структура("Организация",Организация));
	Если НайденныеСтроки.Количество() = 1
		И НайденныеСтроки[0].СертификатПроверен = Истина
		И (НайденныеСтроки[0].ВалидацияСертификатаПройдена = Ложь 
		ИЛИ (ЗначениеЗаполнено(НайденныеСтроки[0].СертификатДействуетПо)
		И КонецДня(НайденныеСтроки[0].СертификатДействуетПо) < ТекущаяДата())) Тогда 
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

&НаКлиенте
Функция ПропускЛогинаПароляДДПоОрганизации(Организация)
	
	НайденныеСтроки = ТаблицаАвторизации.НайтиСтроки(Новый Структура("Организация",Организация));
	Если НайденныеСтроки.Количество() = 1
		И НайденныеСтроки[0].ЛогинПарольДДПроверен = Истина
		И НайденныеСтроки[0].ВалидацияЛогинаПароляДДПройдена = Ложь Тогда 
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

&НаСервере
Процедура ЗаполнитьТаблицуАвторизацииПоУмолчанию() //выбранные в качестве умолчаний
	
	ТаблицаАвторизации.Очистить();
	
	ОтборПоСертификатам = Новый Структура;
	ОтборПоСертификатам.Вставить("СертификатыПоУмолчанию", Истина);
	
	СертификатыПоУмолчанию = МодульОбъекта().ПолучитьТаблицуСохраненныхСертификатов(ОтборПоСертификатам);
	// Пока нет хранения логина пароля ДД в разрезе организации 
	// обойдем и заполним все строки ТаблицаАвторизации одинаковыми значениями
	СтруктураЛогинПарольДД = МодульОбъекта().ПолучитьСписокСвойствEDI("ЛогинСлужебныйДиадок,ПарольСлужебныйДиадок");
	
	Для Каждого СертПоУмолчанию Из СертификатыПоУмолчанию Цикл
		НоваяСтрока = ТаблицаАвторизации.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СертПоУмолчанию);
		
		НоваяСтрока.ЛогинДД 	= СтруктураЛогинПарольДД.ЛогинСлужебныйДиадок;
		НоваяСтрока.ПарольДД 	= СтруктураЛогинПарольДД.ПарольСлужебныйДиадок;
	КонецЦикла;
	
КонецПроцедуры

&НаСервере
Процедура УстановитьНовыеИдентификаторыСчетовФактурИТребуемоеДействие()
	//В общем случае будут присутствовать не все идентификаторы
	//Могут быть БезНДС ники, у них есть только ТОРГ12.
	//Может быть УПД.
	
	СменитьСтатусСообщенияНаПодписанВДиадок=Ложь;
	
	Для каждого ПодписаннаяСчетФактура Из СчетаФактурыНаПодписание Цикл
		
		Если ЗначениеЗаполнено(ПодписаннаяСчетФактура.messageId_new) Тогда 
			МодульОбъекта().УстановитьЗначениеСвойстваОбъекта(ПодписаннаяСчетФактура.Ссылка.Документ,"messageId",ПодписаннаяСчетФактура.messageId_new);	
		КонецЕсли;
		
		Если ЗначениеЗаполнено(ПодписаннаяСчетФактура.torg12Id_new) Тогда 
			МодульОбъекта().УстановитьЗначениеСвойстваОбъекта(ПодписаннаяСчетФактура.Ссылка.Документ,"torg12Id",ПодписаннаяСчетФактура.torg12Id_new);	
			СменитьСтатусСообщенияНаПодписанВДиадок=Истина;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(ПодписаннаяСчетФактура.invoiceId_new) Тогда 
			МодульОбъекта().УстановитьЗначениеСвойстваОбъекта(ПодписаннаяСчетФактура.Ссылка.Документ,"invoiceId",ПодписаннаяСчетФактура.invoiceId_new);	
			СменитьСтатусСообщенияНаПодписанВДиадок=Истина;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(ПодписаннаяСчетФактура.UniversalTransferDocumentId_new) Тогда 
			МодульОбъекта().УстановитьЗначениеСвойстваОбъекта(ПодписаннаяСчетФактура.Ссылка.Документ,"UniversalTransferDocumentId",ПодписаннаяСчетФактура.UniversalTransferDocumentId_new);	
			СменитьСтатусСообщенияНаПодписанВДиадок=Истина;
		КонецЕсли;
		
		Если СменитьСтатусСообщенияНаПодписанВДиадок ИЛИ ПодписаннаяСчетФактура.isDraft = Ложь  Тогда 
			
			СвойстваДляЗаписи = Новый Структура("InvoiceReceiptEntityId_OnInvoiceConfirmation, isDraft, DraftOfDocumentPackageSignedByMe", Неопределено, ПодписаннаяСчетФактура.isDraft, Истина);
			
			МодульОбъекта().ЗаписатьДопРеквизитСправочника_КонтурEDI(ПодписаннаяСчетФактура.Ссылка, СвойстваДляЗаписи);
				
			МодульОбъекта().УстановитьСтатусСообщения(ПодписаннаяСчетФактура.Ссылка,  , "INVOIC", "ИсходящийПодписанВДиадок");
			
			МодульОбъекта().ПроставитьПризнакОтправкиALCRPT_ПослеПодписанияВДиадок(ПодписаннаяСчетФактура.Ссылка.Документ, ПодписаннаяСчетФактура.Ссылка.Партнер);
	
		Иначе
			СообщениеОбъект        = ПодписаннаяСчетФактура.Ссылка.ПолучитьОбъект();
			СообщениеОбъект.Статус = "Ожидает отправки";
			МодульОбъекта().СохранитьОбъектСообщения(СообщениеОбъект);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры // УстановитьНовыеИдентификаторыСчетовФактур()

//Прикладные

&НаКлиенте
Функция ПроверитьВыбранныйСертификат(Организация, Отпечаток, СертификатДействуетПо, ПарольКонтейнера = "")
	
	// Проверим, что можем подписать файл выбранным сертификатом
	Результат = ИнициализироватьСтруктуруРезультатаФункции();
	
	Если Не ЗначениеЗаполнено(Отпечаток) Тогда
		Возврат Результат;
	КонецЕсли;
	
	ИмяФайлаДляТеста = ПолучитьИмяВременногоФайла();
	ТестовыйФайл = Новый ТекстовыйДокумент;
	ТестовыйФайл.Записать(ИмяФайлаДляТеста);
	
	ДанныеСертификата = Новый Структура;
	ДанныеСертификата.Вставить("Организация", 			Организация);
	ДанныеСертификата.Вставить("Отпечаток", 			Отпечаток);
	ДанныеСертификата.Вставить("СертификатДействуетПо", СертификатДействуетПо);
		
	Для Сч = 1 По 2 Цикл
		
		РезультатПодписания = ПолучитьПодписьФайлаДокумента(ИмяФайлаДляТеста, Отпечаток, ПарольКонтейнера);
		
		Если ОбработкаИсключенияТипМодуляКриптографии(РезультатПодписания.ОписаниеОшибки, ДанныеСертификата) Тогда
			Продолжить;
		КонецЕсли;
		
		Если РезультатПодписания.Успешно Тогда
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	ПрерватьПодписаниеСертификатомПоГОСТ2001(РезультатПодписания, ДанныеСертификата);

	УдалитьФайлы(ИмяФайлаДляТеста);
	
	Результат.ОписаниеОшибки = РезультатПодписания.ОписаниеОшибки;
	Результат.Успешно = РезультатПодписания.Успешно;
		
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Процедура ПрерватьПодписаниеСертификатомПоГОСТ2001(РезультатПодписания, ДанныеСертификата)
					
	ТипыКриптопровайдераПоГОСТ2001 = Новый Массив;
	ТипыКриптопровайдераПоГОСТ2001.Добавить(2);	
	ТипыКриптопровайдераПоГОСТ2001.Добавить(75);	
	
	Если ИспользоватьCapicom = Истина Тогда
		Сертификат = ПолучитьСертификатCapicom(ДанныеСертификата.Отпечаток, 3);
		ТипМодуляКриптографии = Сертификат.PrivateKey.ProviderType;			
	Иначе
		ТипМодуляКриптографии = ДанныеАвторизации.ТипМодуляКриптографии;			
	КонецЕсли;
	
	Если ТипыКриптопровайдераПоГОСТ2001.Найти(ТипМодуляКриптографии) = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ПрерватьОбработку = Ложь;
	
	Если ТекущаяДата() > Дата(2020, 1, 1) Тогда
		
		ПрерватьОбработку = Истина;
		ОписаниеОшибки = "Подписание документов невозможно по организации - '" + 
			Строка(ДанныеСертификата.Организация) + "'.
			|Выбранный сертификат выпущен по ГОСТ 2001, отпечаток - " + ДанныеСертификата.Отпечаток + ".
			|Необходимо получить новый сертификат или выбрать существующий, выпущенный по ГОСТ 2012.";
		
	Иначе
		
		ПрерватьОбработку = НЕ ЕстьОтметкаУведомленияОСертификатеПоГОСТ2001Сервер(ДанныеСертификата.Отпечаток);
		ОписаниеОшибки = "С 1 января 2020 года подписание документов будет невозможно по организации - '" + 
			Строка(ДанныеСертификата.Организация) + "'.
			|Выбранный сертификат выпущен по ГОСТ 2001, отпечаток - " + ДанныеСертификата.Отпечаток + ".
			|Необходимо получить новый сертификат или выбрать существующий, выпущенный по ГОСТ 2012.";
		
	КонецЕсли;
	
	РезультатПодписания.ОписаниеОшибки = ОписаниеОшибки;
	РезультатПодписания.Успешно = НЕ ПрерватьОбработку;
	
КонецПроцедуры

&НаСервере
Функция ЕстьОтметкаУведомленияОСертификатеПоГОСТ2001Сервер(Отпечаток)
	
	ЕстьОтметка = МодульОбъекта().ЕстьОтметкаУведомленияОСертификатеПоГОСТ2001(Отпечаток);
	Возврат ЕстьОтметка;
	
КонецФункции

&НаКлиенте
Функция ПроверитьЛогинПарольДД(ДанныеАвторизации)
	
	// Проверим, что можем авторизоваться с указанными данными
	Результат = ИнициализироватьСтруктуруРезультатаФункции();
	
	Если Не ЗначениеЗаполнено(ДанныеАвторизации.ЛогинДД) 
		ИЛИ Не ЗначениеЗаполнено(ДанныеАвторизации.ПарольДД) Тогда
		Результат.ОписаниеОшибки = "Не указаны логин или пароль для доступа в Диадок.";
		ОбновитьДанныеАвторизации("ЛогинПарольДДПроверен", Истина);
		Возврат Результат;
	КонецЕсли;
	
	Ответ = DD_API_Authenticate_НаСервере(,ДанныеАвторизации.ЛогинДД, ДанныеАвторизации.ПарольДД);	
	
	Если Ответ.КодСостояния <> "200" Тогда
		
		ОписаниеОшибки = "Ошибка HTTP запроса"
		+ ?(ЗначениеЗаполнено(Ответ.КодСостояния), Символы.ПС + Ответ.КодСостояния, "")
		+ ?(ЗначениеЗаполнено(Ответ.ТелоОтвета)  , Символы.ПС + Ответ.ТелоОтвета  , "");
		
		ВызватьИсключение ОписаниеОшибки;
		
	КонецЕсли;
	
	ОбновитьДанныеАвторизации("ЛогинПарольДДПроверен", Истина);
	ОбновитьДанныеАвторизации("ВалидацияЛогинаПароляДДПройдена", Истина);
	Результат.Успешно = Истина;
	
  	Возврат Результат;

КонецФункции

&НаКлиенте
Функция УзнатьСостояниепоСФ(ЗНАЧ Организация,ЗНАЧ BoxId,ЗНАЧ MessageId) Экспорт
	
	СтруктураРезультата = ИнициализироватьСтруктуруРезультатаФункции();
	ИнициализироватьДанныеАвторизации(Организация);
	
	Если ДанныеАвторизации = Неопределено Тогда
		// не удалось получить данные авторизации
		Возврат СтруктураРезультата;
	КонецЕсли;
	
	Если (ПропускЛогинаПароляДДПоОрганизации(Организация)
		И Не СертификатПоОрганизацииНазначен(Организация))
		ИЛИ (ПропускЛогинаПароляДДПоОрганизации(Организация)
		И ПропускСертификатаПоОрганизации(Организация)) Тогда
		// не удалось авторизоваться с указанными данными
		Возврат СтруктураРезультата;
	КонецЕсли;

	Если Не ДанныеАвторизации.ЛогинПарольДДПроверен = Истина Тогда
		
		// сначала авторизуемся по логину и паролю
		ОбновитьДанныеАвторизации("ТипАвторизации", "ЛогинПароль");
		РезультатПроверкиЛогинаПароляДД = ПроверитьЛогинПарольДД(ДанныеАвторизации);
		
	КонецЕсли;
		
	Если ПропускЛогинаПароляДДПоОрганизации(Организация)
		И СертификатПоОрганизацииНазначен(Организация)
		И Не ДанныеАвторизации.СертификатПроверен Тогда
		
		// если авторизоваться по логину и паролю не удалось, будем пробовать по сертификату
		ОбновитьДанныеАвторизации("ТипАвторизации", "Сертификат");
		РезультатПроверкиСертификата = Новый Структура("Успешно, ОписаниеОшибки");
		
		ПарольКонтейнера = "";
		РезультатПроверки = ПроверитьВыбранныйСертификат(ДанныеАвторизации.Организация, ДанныеАвторизации.Отпечаток, ДанныеАвторизации.СертификатДействуетПо, ПарольКонтейнера);
		
		Если Не ИспользоватьCapicom
			И РезультатПроверки.Успешно = Ложь
			И ОшибкаНеправильныйПарольКонтейнера(РезультатПроверки.ОписаниеОшибки) Тогда
			
			ПарольКонтейнера = ПолучитьПарольКонтейнераСертификатаСервер(ДанныеАвторизации.Организация, ДанныеАвторизации.Отпечаток);
			РезультатПроверки = ПроверитьВыбранныйСертификат(ДанныеАвторизации.Организация, ДанныеАвторизации.Отпечаток, ДанныеАвторизации.СертификатДействуетПо, ПарольКонтейнера);
			
		КонецЕсли;

		ОбновитьДанныеАвторизации("СертификатПроверен", Истина);
		
		Если РезультатПроверки.Успешно = Истина Тогда
			ОбновитьДанныеАвторизации("ПарольКонтейнера", ПарольКонтейнера);
			ОбновитьДанныеАвторизации("ВалидацияСертификатаПройдена", Истина);
		Иначе
			ОбновитьДанныеАвторизации("ВалидацияСертификатаПройдена", Ложь);
		КонецЕсли;
		
		РезультатПроверкиСертификата.Успешно = РезультатПроверки.Успешно;
		РезультатПроверкиСертификата.ОписаниеОшибки = РезультатПроверки.ОписаниеОшибки;
			
	КонецЕсли;
	
	Если ПропускЛогинаПароляДДПоОрганизации(Организация) Тогда 
		
		Если СертификатПоОрганизацииНазначен(Организация)
			И ПропускСертификатаПоОрганизации(Организация) Тогда
			
			СтруктураРезультата.ОписаниеОшибки = РезультатПроверкиСертификата.ОписаниеОшибки;
			
			Если ЗначениеЗаполнено(ДанныеАвторизации.СертификатДействуетПо)
				И КонецДня(ДанныеАвторизации.СертификатДействуетПо) < ТекущаяДата() Тогда
			    СтруктураРезультата.ОписаниеОшибки = "Истек срок действия сертификата." + Символы.ПС + СтруктураРезультата.ОписаниеОшибки;
			КонецЕсли; 
				
			Возврат СтруктураРезультата;
			
		ИначеЕсли Не СертификатПоОрганизацииНазначен(Организация) Тогда
			
			СтруктураРезультата.ОписаниеОшибки = РезультатПроверкиЛогинаПароляДД.ОписаниеОшибки;
			Возврат СтруктураРезультата;

		КонецЕсли; 
		
	КонецЕсли; 
	
	СтруктураРезультата.Вставить("СтатусСФ","");    			//статусы подписей
	СтруктураРезультата.Вставить("СтатусТорг12","");
	СтруктураРезультата.Вставить("СтатусУПД","");
	
	СтруктураРезультата.Вставить("ФлагЗапросаУточненияСФ","");  //уточнений
	СтруктураРезультата.Вставить("ФлагЗапросаУточненияУПД","");
	
	СтруктураРезультата.Вставить("СтатусАннулированияСФ","");   //аннулирований
	СтруктураРезультата.Вставить("СтатусАннулированияТорг12","");
	СтруктураРезультата.Вставить("СтатусАннулированияУПД","");
	
	СтруктураРезультата.Вставить("КомментарийКЗапросуУточнения","");  //комментариев
	СтруктураРезультата.Вставить("КомментарийКОтказуВПодписи","");
	СтруктураРезультата.Вставить("КомментарийКЗапросуАннулированияСФ","");
	СтруктураРезультата.Вставить("КомментарийКЗапросуАннулированияТорг12","");
	СтруктураРезультата.Вставить("КомментарийКЗапросуАннулированияУПД","");
	
	Message = ПолучитьMessage(BoxId, MessageId, ДанныеАвторизации);
	СтруктураРезультата.Успешно = Message.Успешно;
	
	Если  Message.Успешно Тогда
		//мы будем искать среди entities:
		//Invoice
		//XmlTorg12
		//UniversalTransferDocument
		
		Для каждого Entity из Message.Значение.Entities Цикл
			Если Entity.AttachmentType = "Invoice" Тогда
				СтруктураРезультата.СтатусСФ = Entity.DocumentInfo.InvoiceMetadata.InvoiceStatus;
				СтруктураРезультата.ФлагЗапросаУточненияСФ = Entity.DocumentInfo.InvoiceMetadata.InvoiceAmendmentFlags;
				СтруктураРезультата.СтатусАннулированияСФ = Entity.DocumentInfo.RevocationStatus;
				Если СтруктураРезультата.СтатусАннулированияСФ = "RevocationStatusNone" Тогда 
					 СтруктураРезультата.СтатусАннулированияСФ=""; //не будем никого путать этот статус проще вообще не показывать 
				КонецЕсли;
			КонецЕсли;
			Если Entity.AttachmentType = "InvoiceCorrection" Тогда
				СтруктураРезультата.СтатусСФ = Entity.DocumentInfo.InvoiceCorrectionMetadata.InvoiceCorrectionStatus;
				СтруктураРезультата.ФлагЗапросаУточненияСФ = Entity.DocumentInfo.InvoiceCorrectionMetadata.InvoiceAmendmentFlags;
				СтруктураРезультата.СтатусАннулированияСФ = Entity.DocumentInfo.RevocationStatus;
				Если СтруктураРезультата.СтатусАннулированияСФ = "RevocationStatusNone" Тогда 
					 СтруктураРезультата.СтатусАннулированияСФ=""; //не будем никого путать этот статус проще вообще не показывать 
				КонецЕсли;
			КонецЕсли;
			Если Entity.AttachmentType = "InvoiceRevision" Тогда
				СтруктураРезультата.СтатусСФ = Entity.DocumentInfo.InvoiceRevisionMetadata.InvoiceRevisionStatus;
				СтруктураРезультата.ФлагЗапросаУточненияСФ = Entity.DocumentInfo.InvoiceRevisionMetadata.InvoiceAmendmentFlags;
				СтруктураРезультата.СтатусАннулированияСФ = Entity.DocumentInfo.RevocationStatus;
				Если СтруктураРезультата.СтатусАннулированияСФ = "RevocationStatusNone" Тогда 
					СтруктураРезультата.СтатусАннулированияСФ=""; //не будем никого путать этот статус проще вообще не показывать 
				КонецЕсли;
			КонецЕсли;
			Если Entity.AttachmentType = "XmlTorg12" Тогда
				СтруктураРезультата.СтатусТорг12 = Entity.DocumentInfo.XmlTorg12Metadata.DocumentStatus;
				СтруктураРезультата.СтатусАннулированияТорг12 = Entity.DocumentInfo.RevocationStatus;           
				Если СтруктураРезультата.СтатусАннулированияТорг12 = "RevocationStatusNone" Тогда 
					 СтруктураРезультата.СтатусАннулированияТорг12=""; //не будем никого путать этот статус проще вообще не показывать 
				КонецЕсли;
			КонецЕсли;
			Если Entity.AttachmentType = "UniversalTransferDocument" Тогда
				СтруктураРезультата.СтатусУПД = Entity.DocumentInfo.UniversalTransferDocumentMetadata.DocumentStatus;
				СтруктураРезультата.ФлагЗапросаУточненияУПД = Entity.DocumentInfo.UniversalTransferDocumentMetadata.InvoiceAmendmentFlags;
				СтруктураРезультата.СтатусАннулированияУПД = Entity.DocumentInfo.RevocationStatus;
				Если СтруктураРезультата.СтатусАннулированияУПД = "RevocationStatusNone" Тогда 
					 СтруктураРезультата.СтатусАннулированияУПД=""; //не будем никого путать этот статус проще вообще не показывать 
				КонецЕсли;
			КонецЕсли;
			Если Entity.AttachmentType = "UniversalTransferDocumentRevision" Тогда
				СтруктураРезультата.СтатусУПД = Entity.DocumentInfo.UniversalTransferDocumentRevisionMetadata.DocumentStatus;
				СтруктураРезультата.ФлагЗапросаУточненияУПД = Entity.DocumentInfo.UniversalTransferDocumentRevisionMetadata.InvoiceAmendmentFlags;
				СтруктураРезультата.СтатусАннулированияУПД = Entity.DocumentInfo.RevocationStatus;
				Если СтруктураРезультата.СтатусАннулированияУПД = "RevocationStatusNone" Тогда 
					 СтруктураРезультата.СтатусАннулированияУПД=""; //не будем никого путать этот статус проще вообще не показывать 
				КонецЕсли;
			КонецЕсли;
			Если Entity.AttachmentType = "UniversalCorrectionDocument" Тогда
				СтруктураРезультата.СтатусУПД = Entity.DocumentInfo.UniversalCorrectionDocumentMetadata.DocumentStatus;
				СтруктураРезультата.ФлагЗапросаУточненияУПД = Entity.DocumentInfo.UniversalCorrectionDocumentMetadata.InvoiceAmendmentFlags;
				СтруктураРезультата.СтатусАннулированияУПД = Entity.DocumentInfo.RevocationStatus;
				Если СтруктураРезультата.СтатусАннулированияУПД = "RevocationStatusNone" Тогда 
					 СтруктураРезультата.СтатусАннулированияУПД=""; //не будем никого путать этот статус проще вообще не показывать 
				КонецЕсли;
			КонецЕсли;
			Если Entity.AttachmentType = "UniversalCorrectionDocumentRevision" Тогда
				СтруктураРезультата.СтатусУПД = Entity.DocumentInfo.UniversalCorrectionDocumentRevisionMetadata.DocumentStatus;
				СтруктураРезультата.ФлагЗапросаУточненияУПД = Entity.DocumentInfo.UniversalCorrectionDocumentRevisionMetadata.InvoiceAmendmentFlags;
				СтруктураРезультата.СтатусАннулированияУПД = Entity.DocumentInfo.RevocationStatus;
				Если СтруктураРезультата.СтатусАннулированияУПД = "RevocationStatusNone" Тогда 
					 СтруктураРезультата.СтатусАннулированияУПД=""; //не будем никого путать этот статус проще вообще не показывать 
				КонецЕсли;
			КонецЕсли;
			//здесь ищем сами сущности корректировок чтобы прочитать из них комментарий
			Если Entity.AttachmentType = "InvoiceCorrectionRequest" Тогда
				СтруктураРезультата.КомментарийКЗапросуУточнения = ПрочитатьКомментарийУточненияИлиОтказа(BoxId,MessageId,Entity.EntityId,ДанныеАвторизации);
			КонецЕсли;                                             
			Если Entity.AttachmentType = "XmlSignatureRejection" Тогда
				СтруктураРезультата.КомментарийКОтказуВПодписи = ПрочитатьКомментарийУточненияИлиОтказа(BoxId,MessageId,Entity.EntityId,ДанныеАвторизации);
			КонецЕсли;                                             
			Если Entity.AttachmentType = "RevocationRequest" Тогда
				РодительЗапросаАннулирования = ОпределитьРодителяEntity(Message.Значение.Entities,Entity);
				КомментарийКЗапросуАннулирования = ПрочитатьКомментарийЗапросаАннулирования(BoxId,MessageId,Entity.EntityId,ДанныеАвторизации);
				Если РодительЗапросаАннулирования.AttachmentType = "Invoice" Тогда
					СтруктураРезультата.КомментарийКЗапросуАннулированияСФ = КомментарийКЗапросуАннулирования;
				ИначеЕсли РодительЗапросаАннулирования.AttachmentType = "XmlTorg12" Тогда
					СтруктураРезультата.КомментарийКЗапросуАннулированияТОРГ12 = КомментарийКЗапросуАннулирования;
				ИначеЕсли РодительЗапросаАннулирования.AttachmentType = "UniversalTransferDocument" Тогда
					СтруктураРезультата.КомментарийКЗапросуАннулированияУПД = КомментарийКЗапросуАннулирования;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
	Иначе
		ТекстСообщения = "Не удалось получить документы из Диадок для уточнения статуса";
		СтруктураРезультата.ОписаниеОшибки = ТекстСообщения;
	КонецЕсли;
	
	Возврат  СтруктураРезультата
	
КонецФункции

&НаКлиенте
Функция ОпределитьРодителяEntity(МассивEntities,ТекEntityИзМассива)
	
	Для каждого Entity из МассивEntities Цикл
		Если ТекEntityИзМассива.ParentEntityId = Entity.EntityId Тогда 
			Возврат Entity;
		КонецЕсли;
	КонецЦикла;
		
	Возврат Неопределено;

КонецФункции // ОпределитьРодителяEntity()

&НаКлиенте
Функция СохранитьКонтентВФайл(BoxId,MessageId,EntityId,ДанныеАвторизации)
	
	мРабочийКаталог=КаталогВременныхФайлов();
	ПутьКФайлу=мРабочийКаталог+EntityId;
	ВременныйФайл = Новый Файл(ПутьКФайлу);
	Если ВременныйФайл.Существует() Тогда
		УдалитьФайлы(ВременныйФайл.ПолноеИмя);//Если такой файл уже есть в temp, значит, он остался от предыдущей сессии, когда чо-то пошло не так. Удалим его.
	КонецЕсли;
	
 	Результат=СохранитьКонтентВложения(BoxId, MessageId, EntityId, ДанныеАвторизации, ПутьКФайлу);
	Результат.Вставить("ПутьКФайлу",ПутьКФайлу);
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Функция ПолучитьТекстФайлаКонтента(BoxId,MessageId,EntityId,ДанныеАвторизации)
	
	РезультатСохраненияКонтента=СохранитьКонтентВФайл(BoxId,MessageId,EntityId,ДанныеАвторизации);
	
	Если РезультатСохраненияКонтента.Успешно = Истина Тогда 
		//из файлика нам нужен тег <ТекстУведУточ>
		
		ТекстXML = Новый ТекстовыйДокумент;
		ТекстXML.Прочитать(РезультатСохраненияКонтента.ПутьКФайлу);
		ТекстXML = ТекстXML.ПолучитьТекст();
		
		Возврат ТекстXML;
	Иначе
		МодульОбъектаКлиент().СообщениеПользователю_КонтурEDI(РезультатСохраненияКонтента.ОписаниеОшибки);
		Возврат "Не удалось прочитать комментарий";
	КонецЕсли;

КонецФункции

&НаКлиенте
Функция ПрочитатьКомментарийУточненияИлиОтказа(BoxId,MessageId,EntityId,ДанныеАвторизации)
	
	ТекстXML=ПолучитьТекстФайлаКонтента(BoxId,MessageId,EntityId,ДанныеАвторизации);
	
	//не будим загонять в XDTO
	ПозСутиКомментария=Найти(ТекстXML,"<ТекстУведУточ>");
	Если ПозСутиКомментария<>0 Тогда
		ПозОкончанияКомментария=Найти(ТекстXML,"</ТекстУведУточ>");
		ТекстКомментария=Сред(ТекстXML,ПозСутиКомментария+15,ПозОкончанияКомментария-ПозСутиКомментария-15);
		Возврат СокрЛП(ТекстКомментария);
	Иначе
		Возврат ?(ЗначениеЗаполнено(ТекстXML),ТекстXML,"");
	КонецЕсли;
	
КонецФункции

&НаКлиенте
Функция ПрочитатьКомментарийЗапросаАннулирования(BoxId,MessageId,EntityId,ДанныеАвторизации)
	
	ТекстXML=ПолучитьТекстФайлаКонтента(BoxId,MessageId,EntityId,ДанныеАвторизации);
	//даже не будим загонять в XDTO
	ПозСутиКомментария=Найти(ТекстXML,"<ТекстПредАн>");
	Если ПозСутиКомментария<>0 Тогда
		ПозОкончанияКомментария=Найти(ТекстXML,"</ТекстПредАн>");
		ТекстКомментария=Сред(ТекстXML,ПозСутиКомментария+13,ПозОкончанияКомментария-ПозСутиКомментария-13);
		Возврат СокрЛП(ТекстКомментария);
	Иначе
		Возврат ?(ЗначениеЗаполнено(ТекстXML),ТекстXML,"");
	КонецЕсли;
	
КонецФункции

&НаКлиенте
Функция ПолучитьСостояниеСообщенияINVOICПоСостояниюЮЗДО(СтруктураСостояния) Экспорт
	
	Возврат ПолучитьСостояниеСообщенияINVOICПоСостояниюЮЗДОСервер(СтруктураСостояния);
	
КонецФункции

&НаСервере
Функция ПолучитьСостояниеСообщенияINVOICПоСостояниюЮЗДОСервер(СтруктураСостояния)

	Возврат МодульОбъекта().ПолучитьСостояниеСообщенияINVOICПоСостояниюЮЗДО(СтруктураСостояния)	
	
КонецФункции 

&НаКлиенте
Процедура СброситьПроверкиДанныхАвторизации() Экспорт

	Для каждого Строка Из ТаблицаАвторизации Цикл
		
		Строка.ЛогинПарольДДПроверен 			= Ложь;
		Строка.СертификатПроверен 				= Ложь;
		Строка.ВалидацияЛогинаПароляДДПройдена 	= Ложь;
		Строка.ВалидацияСертификатаПройдена 	= Ложь;
	
	КонецЦикла;

КонецПроцедуры

&НаКлиенте
Процедура СброситьПарольКонтейнераДанныхАвторизации() Экспорт
	
	ОбновитьДанныеАвторизации("ПарольКонтейнера", "");

	Для каждого Строка Из ТаблицаАвторизации Цикл
		Строка.ПарольКонтейнера	= "";
	КонецЦикла;

КонецПроцедуры

&НаКлиенте
Процедура ПодписатьСчетаФактуры()
	
	мРабочийКаталог = КаталогВременныхФайлов();
	Прогресс = 0;
	Всего = СчетаФактурыНаПодписание.Количество();
	
	МассивПодписанныхСчетФактур = Новый Массив;
	
	Для Каждого СчетФактураКПодписи Из СчетаФактурыНаПодписание Цикл
		
		Прогресс = Прогресс + 1;
		ТекПроцент = Цел((Прогресс * 100 / Всего)); 
		Состояние("Подписание в Диадок: " + Прогресс + " из " + Всего, ТекПроцент);
		
		Если НЕ СчетФактураКПодписи.Организация = ДанныеАвторизации.Организация Тогда
			ИнициализироватьДанныеАвторизации(СчетФактураКПодписи.Организация);
		КонецЕсли;
		
		Если ПропускСертификатаПоОрганизации(СчетФактураКПодписи.Организация) Тогда
			// по какой-то причине не удалось выбрать сертификат или не прошли проверку с сертификатом
			Продолжить; 
		КонецЕсли;
		
		MessageЧерновик = ПолучитьMessage(СчетФактураКПодписи.BoxId,СчетФактураКПодписи.MessageId,ДанныеАвторизации);
		
		Если MessageЧерновик.Успешно = Ложь Тогда
			ТекстСообщения = "Не удалось получить документы из Диадок для подписания";
			МодульОбъектаКлиент().СообщениеПользователю_КонтурEDI(ТекстСообщения);
			Возврат;
		КонецЕсли;
		
		СчетФактураКПодписи.IsDraft = MessageЧерновик.Значение.IsDraft;
		
		// Временный массив, куда сложим все  Entities, которые нужно подписать
		EntitiesДляПодписания = ПолучитьEntitiesДляПодписания(MessageЧерновик);
		
		// Массив, перед подписанием проставим подписантов во всех Entites документов Message.
		PatchedEntities = ПолучитьPatchedEntities(EntitiesДляПодписания, СчетФактураКПодписи, ДанныеАвторизации, СчетФактураКПодписи.IsDraft);
		Если Не ЗначениеЗаполнено(PatchedEntities) Тогда
			Продолжить;
		КонецЕсли;
		
		Если НЕ СчетФактураКПодписи.IsDraft Тогда
			
			РезультатПолученияMessagePatchToPost = ПолучитьСтруктуруMessagePatchToPost(MessageЧерновик.Значение, СчетФактураКПодписи.BoxId, СчетФактураКПодписи.MessageId, ДанныеАвторизации, PatchedEntities);
			
			Если НЕ РезультатПолученияMessagePatchToPost.Успешно Тогда
				Возврат;
			КонецЕсли;
			
			Результат = ОтправитьMessagePatch(РезультатПолученияMessagePatchToPost.MessagePatchToPost, ДанныеАвторизации); 	
			
			Если Результат = Неопределено Тогда
				Возврат;
			КонецЕсли; 
			
			Если ТипЗнч(Результат) = Тип("Структура") Тогда
				
				СчетФактураКПодписи.MessageId_new					= Результат.MessageId;
				СчетФактураКПодписи.invoiceId_new					= СчетФактураКПодписи.invoiceId;
				СчетФактураКПодписи.UniversalTransferDocumentId_new	= СчетФактураКПодписи.UniversalTransferDocumentId;
				СчетФактураКПодписи.torg12Id_new					= СчетФактураКПодписи.torg12Id;
				
			КонецЕсли;
			
			СтруктураПодписанныхСчетФактур = Новый Структура("Ссылка, messageId_new, torg12Id_new, invoiceId_new, UniversalTransferDocumentId_new, isDraft");
			ЗаполнитьЗначенияСвойств(СтруктураПодписанныхСчетФактур, СчетФактураКПодписи);
			МассивПодписанныхСчетФактур.Добавить(СтруктураПодписанныхСчетФактур); 
						
		Иначе  
			
			MessagePatchToPost = Новый Структура;  //это итоговая структура, которую будем отправлять
			MessagePatchToPost.Вставить("BoxId", 		СчетФактураКПодписи.BoxId);
			MessagePatchToPost.Вставить("DraftId", 	СчетФактураКПодписи.MessageId);
									
			// это нужно будет добавить в MessagePatchToPost как DocumentSignatures (ниже)
			// в ней будут все подписанные attachement от этого сообщения
			МассивСтруктур = Новый Массив;   
			
			Для Каждого PatchedEntity Из PatchedEntities Цикл
				РезультатПодписания = ПодписатьPatchedEntity(PatchedEntity, МассивСтруктур, ДанныеАвторизации);
				Если РезультатПодписания.Успешно = Ложь Тогда
					МодульОбъектаКлиент().СообщениеПользователю_КонтурEDI(РезультатПодписания.ОписаниеОшибки);
					Продолжить;
				КонецЕсли;
			КонецЦикла;
			
			MessagePatchToPost.Вставить("DocumentSignatures", 	МассивСтруктур);
			
			//Отправка
			Результат = Неопределено;
			Если МассивСтруктур.Количество()>0 Тогда 
				Результат=ОтправитьSendDraft(MessagePatchToPost,ДанныеАвторизации);  //sendDraft - очень похож на патч.
			КонецЕсли;
			
			//Отражение результатов - укажем в нашей табличке новые идентификаторы
			Если Результат<>Неопределено Тогда 
				Если ТипЗнч(Результат)=Тип("Структура") Тогда 
					СчетФактураКПодписи.MessageId_new=Результат.MessageId;
					//теперь найти invoiceID, torg12Id, updID
					Если ТипЗнч(Результат.Entities)=Тип("Массив")
						И Результат.Entities.Количество()>0 Тогда 
						Для Каждого Entity из Результат.Entities Цикл
							Если Entity.AttachmentType="Invoice" или Entity.AttachmentType="InvoiceCorrection" Тогда 
								СчетФактураКПодписи.InvoiceId_new = Entity.EntityId;
							ИначеЕсли Entity.AttachmentType="XmlTorg12" Тогда 
								СчетФактураКПодписи.torg12Id_new = Entity.EntityId;
							ИначеЕсли Entity.AttachmentType = "UniversalTransferDocument" или Entity.AttachmentType = "UniversalTransferDocumentRevision" Тогда 
								СчетФактураКПодписи.UniversalTransferDocumentId_new = Entity.EntityId;     //УПД
							ИначеЕсли Entity.AttachmentType = "UniversalCorrectionDocument" или Entity.AttachmentType = "UniversalCorrectionDocumentRevision" Тогда 
								СчетФактураКПодписи.UniversalTransferDocumentId_new = Entity.EntityId;     //УКД пишем тоже в  UniversalTransferDocumentId
							КонецЕсли;
						КонецЦикла;
					КонецЕсли;
					
					СтруктураПодписанныхСчетФактур = Новый Структура("Ссылка, messageId_new, torg12Id_new, invoiceId_new, UniversalTransferDocumentId_new, isDraft");
					ЗаполнитьЗначенияСвойств(СтруктураПодписанныхСчетФактур, СчетФактураКПодписи);
					МассивПодписанныхСчетФактур.Добавить(СтруктураПодписанныхСчетФактур);
					
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	ВыполнитьОбработкуПодписанныхДокументов_КонтурEDI(МассивПодписанныхСчетФактур);
	
	Состояние("Подписание в Диадок: завершено");
	
КонецПроцедуры

&НаСервере 
Процедура ВыполнитьОбработкуПодписанныхДокументов_КонтурEDI(МассивПодписанныхСчетФактур) 
	
	Для Каждого ПодписаннаяСчетФактура Из МассивПодписанныхСчетФактур Цикл 
		
		СменитьСтатусСообщенияНаПодписанВДиадок = (ПодписаннаяСчетФактура.isDraft = Ложь);
		
		Если ЗначениеЗаполнено(ПодписаннаяСчетФактура.messageId_new) Тогда 
			МодульОбъекта().УстановитьЗначениеСвойстваОбъекта(ПодписаннаяСчетФактура.Ссылка.Документ, "messageId", ПодписаннаяСчетФактура.messageId_new);	
		КонецЕсли;
		
		Если ЗначениеЗаполнено(ПодписаннаяСчетФактура.torg12Id_new) Тогда 
			МодульОбъекта().УстановитьЗначениеСвойстваОбъекта(ПодписаннаяСчетФактура.Ссылка.Документ, "torg12Id", ПодписаннаяСчетФактура.torg12Id_new);	
			СменитьСтатусСообщенияНаПодписанВДиадок = Истина;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(ПодписаннаяСчетФактура.invoiceId_new) Тогда 
			МодульОбъекта().УстановитьЗначениеСвойстваОбъекта(ПодписаннаяСчетФактура.Ссылка.Документ, "invoiceId", ПодписаннаяСчетФактура.invoiceId_new);	
			СменитьСтатусСообщенияНаПодписанВДиадок = Истина;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(ПодписаннаяСчетФактура.UniversalTransferDocumentId_new) Тогда 
			МодульОбъекта().УстановитьЗначениеСвойстваОбъекта(ПодписаннаяСчетФактура.Ссылка.Документ, "UniversalTransferDocumentId", ПодписаннаяСчетФактура.UniversalTransferDocumentId_new);	
			СменитьСтатусСообщенияНаПодписанВДиадок = Истина;
		КонецЕсли;
		
		Если СменитьСтатусСообщенияНаПодписанВДиадок Тогда 
			
			СвойстваДляЗаписи = Новый Структура("InvoiceReceiptEntityId_OnInvoiceConfirmation, isDraft, DraftOfDocumentPackageSignedByMe", Неопределено, ПодписаннаяСчетФактура.isDraft, Истина);
			
			МодульОбъекта().ЗаписатьДопРеквизитСправочника_КонтурEDI(ПодписаннаяСчетФактура.Ссылка, СвойстваДляЗаписи);
				
			МодульОбъекта().УстановитьСтатусСообщения(ПодписаннаяСчетФактура.Ссылка,  , "INVOIC", "ИсходящийПодписанВДиадок");
			
			МодульОбъекта().ПроставитьПризнакОтправкиALCRPT_ПослеПодписанияВДиадок(ПодписаннаяСчетФактура.Ссылка.Документ, ПодписаннаяСчетФактура.Ссылка.Партнер);
	
		Иначе
			СообщениеОбъект        = ПодписаннаяСчетФактура.Ссылка.ПолучитьОбъект();
			СообщениеОбъект.Статус = "Ожидает отправки";
			МодульОбъекта().СохранитьОбъектСообщения(СообщениеОбъект);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

&НаКлиенте
Функция ОтправитьMessagePatch(MessagePatchToPost,ДанныеАвторизации)
	
	Результат = PostMessagePatch(ЗаписатьJSONВызовСервера(MessagePatchToPost), , ДанныеАвторизации);
	
	Если Не Результат.Успешно Тогда
		МодульОбъектаКлиент().СообщениеПользователю_КонтурEDI(Результат.ОписаниеОшибки);
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Результат.Значение;		
	
КонецФункции

&НаКлиенте
Функция ПолучитьПодписьКонтентаMessagePatchToPost(MessagePatchToPost,ДанныеАвторизации)
	
	Успешно = Истина;
	
	Signatures = Неопределено;
	Если MessagePatchToPost.Свойство("Signatures", Signatures) Тогда
		ПодписаниеУспешно = ПодписатьКонтентSignatures(Signatures, ДанныеАвторизации);
		Успешно = Успешно И ПодписаниеУспешно;
	КонецЕсли;
	
	RequestedSignatureRejections = Неопределено;
	Если MessagePatchToPost.Свойство("RequestedSignatureRejections", RequestedSignatureRejections) Тогда
		ПодписаниеУспешно = ПодписатьКонтентRequestedSignatureRejections(RequestedSignatureRejections, ДанныеАвторизации);
		Успешно = Успешно И ПодписаниеУспешно;
	КонецЕсли;
	
	Возврат Успешно;	
	
КонецФункции

&НаКлиенте
Функция ПодписатьКонтентRequestedSignatureRejections(RequestedSignatureRejections,ДанныеАвторизации)
	
	Успешно = Истина;
	
	Для Каждого RequestedSignatureRejection Из RequestedSignatureRejections Цикл
		                  
		Если Не RequestedSignatureRejection.SignedContent.Signature = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ПутьКФайлу = RequestedSignatureRejection.SignedContent.ПутьКФайлу;
		РезультатПодписания = ПолучитьПодписьФайлаДокумента(ПутьКФайлу, ДанныеАвторизации.Отпечаток, ДанныеАвторизации.ПарольКонтейнера);
		
		Если НЕ РезультатПодписания.Успешно Тогда
			Возврат Ложь;	
		КонецЕсли;
		
		RequestedSignatureRejection.SignedContent.Signature = РезультатПодписания.ШифрованнаяПодпись;
		
	КонецЦикла;
	
	Возврат Успешно;	
	
КонецФункции

&НаКлиенте
Функция ПодписатьКонтентSignatures(Signatures,ДанныеАвторизации)
	
	Успешно = Истина;
	
	Для Каждого DocumentSignature Из Signatures Цикл
		                  
		Если Не DocumentSignature.Signature = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ПутьКФайлу = DocumentSignature.ПутьКФайлу;
		РезультатПодписания = ПолучитьПодписьФайлаДокумента(ПутьКФайлу, ДанныеАвторизации.Отпечаток, ДанныеАвторизации.ПарольКонтейнера);
		
		Если НЕ РезультатПодписания.Успешно Тогда
			Возврат Ложь;	
		КонецЕсли;
		
		DocumentSignature.Signature = РезультатПодписания.ШифрованнаяПодпись;
		
	КонецЦикла;
	
	Возврат Успешно;	
	
КонецФункции

&НаКлиенте   
Функция ПолучитьСтруктуруMessagePatchToPost(Message,BoxId,MessageId,ДанныеАвторизации,PatchedEntities)
	
	РезультатПолученияMessagePatchToPost = Новый Структура("Успешно, MessagePatchToPost", Истина,  Новый Структура);
	
	Если Message = Неопределено Тогда
		
		РезультатПолученияMessagePatchToPost.Успешно = Ложь;
		
		Возврат РезультатПолученияMessagePatchToPost;
		
	КонецЕсли;
			
	РезультатSignatures = ПолучитьМассивСтруктурSignatures(BoxId, Message, ДанныеАвторизации, PatchedEntities);
	
	Если РезультатSignatures.Успешно Тогда
		
		Signatures = РезультатSignatures.МассивСтруктур;
		
		РезультатПолученияMessagePatchToPost.MessagePatchToPost.Вставить("BoxId", 		BoxId);
		РезультатПолученияMessagePatchToPost.MessagePatchToPost.Вставить("MessageId", 	MessageId);
		РезультатПолученияMessagePatchToPost.MessagePatchToPost.Вставить("Signatures", 	Signatures);
		
	Иначе
		
		РезультатПолученияMessagePatchToPost.Успешно = Ложь;
		Сообщить(РезультатSignatures.ТекстОшибки);
		
	КонецЕсли;
	
	Возврат РезультатПолученияMessagePatchToPost;
	
КонецФункции

&НаКлиенте
Функция СущностьНеЯвляетсяФайломДанныхИлиПечатнойФормой(Entity)
	
	Результат = Истина;
	
	Если Entity.EntityType = "Attachment" Тогда
		Если ( Entity.AttachmentType = "ReconciliationAct" ) или ( Entity.AttachmentType = "Nonformalized" ) Тогда
			Результат = Ложь;
		КонецЕсли;	
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Функция ПолучитьМассивСтруктурSignatures(BoxId, Message, ДанныеАвторизации, PatchedEntities)
	
	Результат = Новый Структура("Успешно,МассивСтруктур,ТекстОшибки", Истина, Неопределено, "");
	
	Entities = Message.Entities;
	Для Каждого PatchedEntity Из PatchedEntities Цикл
				                                
		MessageId = Message.MessageId;
		EntityId = PatchedEntity.DocumentId.EntityId;
		ПутьКФайлу = мРабочийКаталог+Message.MessageId + "_" + PatchedEntity.DocumentId.EntityId;
		
		Если PatchedEntity.Свойство("Content") и ТипЗнч(PatchedEntity.Content) = Тип("Строка") Тогда
			РезультатСохранения = ЗакодированныеДвоичныеДанныеВФайл(PatchedEntity.Content, "base64", ПутьКФайлу);
		Иначе
			РезультатСохранения = СохранитьКонтентВложения(BoxId, MessageId, PatchedEntity.DocumentId.EntityId, ДанныеАвторизации, ПутьКФайлу);
		КонецЕсли;
		
		Если Не РезультатСохранения.Успешно Тогда
			Возврат Неопределено;
		КонецЕсли;  		
						
		DocumentSignature = Новый Структура;
		DocumentSignature.Вставить("ParentEntityId", 			PatchedEntity.DocumentId.EntityId);
		DocumentSignature.Вставить("ПутьКФайлу",				ПутьКФайлу);
		DocumentSignature.Вставить("АдресАрхиваВоВХ",			Неопределено);
		
		ПутьКФайлуПодписи = DocumentSignature.ПутьКФайлу;
		РезультатПодписания = ПолучитьПодписьФайлаДокумента(ПутьКФайлуПодписи, ДанныеАвторизации.Отпечаток, ДанныеАвторизации.ПарольКонтейнера);
		
		Если НЕ РезультатПодписания.Успешно Тогда
			
			Результат.Успешно = Ложь;
			Результат.ТекстОшибки = "Не удалось получить подпись для Entity " + PatchedEntity.DocumentId.EntityId; 
			
			Прервать;
			
		КонецЕсли;
		
		DocumentSignature.Вставить("Signature",					РезультатПодписания.ШифрованнаяПодпись);
		
		DocumentSignature.Вставить("SignWithTestSignature"	, 	Ложь);
		DocumentSignature.Вставить("IsApprovementSignature"	, 	Ложь);
		DocumentSignature.Вставить("SignatureNameOnShelf"	, 	Неопределено);
		DocumentSignature.Вставить("PatchedContentId"		, 	PatchedEntity.PatchedContentId);   //Entity.PatchedContentId

		Если Результат.МассивСтруктур = Неопределено Тогда
			Результат.МассивСтруктур = Новый Массив;
		КонецЕсли;
		
		Результат.МассивСтруктур.Добавить(DocumentSignature);
		
	КонецЦикла;
	
	Если Результат.МассивСтруктур = Неопределено Тогда
		
		Результат.Успешно = Ложь;
		
		Если Результат.ТекстОшибки = "" Тогда
			Результат.ТекстОшибки = "Не удалось получить Signatures. Возможно не передан массив PatchedEntities.";
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Результат;
		
КонецФункции

&НаКлиенте
Функция ЗакодированныеДвоичныеДанныеВФайл(ЗакодированныеДвоичныеДанные, ИмяАлгоритма, ПутьКФайлу)

	Результат = Новый Структура("Успешно", Ложь);
	
	Попытка
	
		Если ИмяАлгоритма = "base64" Тогда
			ДвоичныеДанные = Base64Значение(ЗакодированныеДвоичныеДанные);			
		КонецЕсли;
		
		ДвоичныеДанные.Записать(ПутьКФайлу);
		Результат.Успешно = Истина;
		
	Исключение
		
		ТекстОшибки = "Подписание ДД. Не удалось записать данные в файл - " + ОписаниеОшибки();
		МодульОбъектаКлиент().ЗаписьЖурналаРегистрацииНаКлиенте_КонтурEDI("Ошибка", ТекстОшибки);
		ВызватьИсключение ТекстОшибки;				
		
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Функция ОтправитьSendDraft(MessagePatchToPost,ДанныеАвторизации)
	
	ИспользоватьСохраненныйТокен = Истина;
	
	Для НомерПопытки = 1 По 2 Цикл
		
		Токен = Токен(ДанныеАвторизации, ИспользоватьСохраненныйТокен);
		Ответ = DD_API_SendDraft_НаСервере(Токен, ЗаписатьJSONВызовСервера(MessagePatchToPost));
		
		Если Ответ.КодСостояния = "401" 
			И НомерПопытки = 1 Тогда

			ИспользоватьСохраненныйТокен = Ложь;
			Продолжить;

		КонецЕсли;
		
		Если Ответ.КодСостояния <> "200" Тогда
			
			ОписаниеОшибки = "Ошибка HTTP запроса"
			+ ?(ЗначениеЗаполнено(Ответ.КодСостояния), Символы.ПС + Ответ.КодСостояния, "")
			+ ?(ЗначениеЗаполнено(Ответ.ТелоОтвета)  , Символы.ПС + Ответ.ТелоОтвета  , "");
			
			ВызватьИсключение ОписаниеОшибки;
			
		КонецЕсли;
		
		Возврат DoParseВызовСервера(Ответ.ТелоОтвета);	
		
	КонецЦикла;		
	
КонецФункции

&НаСервере
Функция ЗаписатьJSONВызовСервера(СтруктураВjson)
	
	Возврат МодульОбъекта().ЗаписатьJSON_(СтруктураВjson);	

КонецФункции

&НаКлиенте
Функция ПолучитьMessage(BoxId,MessageId,ДанныеАвторизации)
	
	ИспользоватьСохраненныйТокен = Истина;
	
	Для НомерПопытки = 1 По 2 Цикл
		
		Токен = Токен(ДанныеАвторизации, ИспользоватьСохраненныйТокен);
		Ответ = DD_API_GetMessage_НаСервере(Токен, BoxId, MessageId);
		
		Если Ответ.КодСостояния = "401" 
			И НомерПопытки = 1 Тогда

			ИспользоватьСохраненныйТокен = Ложь;
			Продолжить;

		КонецЕсли;
		
		Если Ответ.КодСостояния <> "200" Тогда
			
			ОписаниеОшибки = "Ошибка HTTP запроса"
			+ ?(ЗначениеЗаполнено(Ответ.КодСостояния), Символы.ПС + Ответ.КодСостояния, "")
			+ ?(ЗначениеЗаполнено(Ответ.ТелоОтвета)  , Символы.ПС + Ответ.ТелоОтвета  , "");
			
			ВызватьИсключение ОписаниеОшибки;
			
		КонецЕсли;
		
		Результат = Новый Структура("Успешно, Значение" , Истина , DoParseВызовСервера(Ответ.ТелоОтвета));
		
		Возврат Результат;
		
	КонецЦикла;
	
КонецФункции

&НаКлиенте
Функция GetInvoiceCorrectionRequestInfo(BoxId, messageId, entityId, ДанныеАвторизации)
	
	ИспользоватьСохраненныйТокен = Истина;
	
	Для НомерПопытки = 1 По 2 Цикл
		
		Токен = Токен(ДанныеАвторизации, ИспользоватьСохраненныйТокен);
		Ответ = DD_API_GetInvoiceCorrectionRequestInfo_НаСервере(Токен, BoxId, messageId, entityId);
		
		Если Ответ.КодСостояния = "401" 
			И НомерПопытки = 1 Тогда

			ИспользоватьСохраненныйТокен = Ложь;
			Продолжить;
			
		КонецЕсли;
		
		Если Ответ.КодСостояния <> "200" Тогда
			
			ОписаниеОшибки = "Ошибка HTTP запроса"
			+ ?(ЗначениеЗаполнено(Ответ.КодСостояния), Символы.ПС + Ответ.КодСостояния, "")
			+ ?(ЗначениеЗаполнено(Ответ.ТелоОтвета)  , Символы.ПС + Ответ.ТелоОтвета  , "");
			
			ВызватьИсключение ОписаниеОшибки;
			
		КонецЕсли;
		
		Возврат DoParseВызовСервера(Ответ.ТелоОтвета);
		
	КонецЦикла;		

КонецФункции

&НаСервере
Функция DoParseВызовСервера(Строка)
	Возврат МодульОбъекта().DoParse(Строка);
КонецФункции

&НаКлиенте
Функция ПолучитьПодписьФайлаДокумента(ПутьКФайлу, Отпечаток, ПарольКонтейнера = "") Экспорт
	
	//серверный аналог функции расположен в модуле объекта
	Результат = ИнициализироватьСтруктуруРезультатаФункции();
	
	Попытка

		Если ИспользоватьCapicom Тогда
			
			Скрипт = Новый COMОбъект("MSScriptControl.ScriptControl");
			Скрипт.language = "vbscript";
			
			Сертификат = ПолучитьСертификатCapicom(Отпечаток, 3);
			
			ТекстСкрипта = "
			|Const FileTypeBinary = 1
			|
			|Function SignFile(SourceFile)
			|
			|	Set objStream = CreateObject(""ADODB.Stream"")
			|	With objStream
			|		.Type = FileTypeBinary
			|		.Open
			|		.LoadFromFile SourceFile
			|	End With
			|	dataToSign = objStream.Read
			|	Set oSigner = CreateObject(""CAPICOM.Signer"")
			|	oSigner.Certificate = certificate
			|	oSigner.Options = 2
			|	Set oSignedData = CreateObject(""CAPICOM.SignedData"")
			|	oSignedData.Content = dataToSign
			|	sSignedMessage = oSignedData.Sign(oSigner, true)
			|
			|	SignFile = sSignedMessage
			|End Function
			|";
			
			Скрипт.AddObject("certificate", Сертификат);
			Скрипт.AddCode(ТекстСкрипта);
			
			ШифрованнаяПодпись = Скрипт.CodeObject.SignFile(ПутьКФайлу);
			ШифрованнаяПодпись = Лев(ШифрованнаяПодпись,СтрДлина(ШифрованнаяПодпись)-2);
			
		Иначе
			
			Сертификат = ПолучитьСертификат1СПоОтпечатку(Отпечаток);
			МенеджерКриптографии = МенеджерКриптографии1С(ПарольКонтейнера);
			Подпись = МенеджерКриптографии.Подписать(ПутьКФайлу, Сертификат);
			ШифрованнаяПодпись = Base64Строка(Подпись);
			
		КонецЕсли;
		
		Результат.Успешно = Истина;
		Результат.Вставить("ШифрованнаяПодпись", ШифрованнаяПодпись);
		
	Исключение
		
		_ИнформацияОбОшибке = ИнформацияОбОшибке();
		Результат.ОписаниеОшибки = _ИнформацияОбОшибке.Причина.Описание;
		
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Функция СохранитьКонтентВложения(BoxId, MessageId, EntityId, ДанныеАвторизации, ПутьКФайлу)
	
	Результат = ИнициализироватьСтруктуруРезультатаФункции();
	
	ИспользоватьСохраненныйТокен = Истина;
	
	Для НомерПопытки = 1 По 2 Цикл
		
		Токен = Токен(ДанныеАвторизации, ИспользоватьСохраненныйТокен);
		Ответ = DD_API_GetEntityContent_НаСервере(Токен, BoxId, MessageId, EntityId);
		
		Если Ответ.КодСостояния = "401" 
			И НомерПопытки = 1 Тогда

			ИспользоватьСохраненныйТокен = Ложь;
			Продолжить;

		КонецЕсли;
		
		Если Ответ.КодСостояния <> "200" Тогда
			
			ОписаниеОшибки = "Ошибка HTTP запроса"
			+ ?(ЗначениеЗаполнено(Ответ.КодСостояния), Символы.ПС + Ответ.КодСостояния, "")
			+ ?(ЗначениеЗаполнено(Ответ.ТелоОтвета)  , Символы.ПС + Ответ.ТелоОтвета  , "");
			
			ВызватьИсключение ОписаниеОшибки;
			
		КонецЕсли;
		
		ДвоичныеДанные = Ответ.ТелоОтвета;
		ДвоичныеДанные.Записать(ПутьКФайлу);
		
		ФайлКонтентаВложения = Новый Файл(ПутьКФайлу);
		Если Не ФайлКонтентаВложения.Существует() Тогда
			ВызватьИсключение "не удалось сохранить файл на диск";
		КонецЕсли;
		
		Результат.Успешно = Истина;
		Возврат Результат;
		
	КонецЦикла;
	
КонецФункции

&НаКлиенте
Функция COMSafeArrayToBinary(МассивДанных)
	
	МассивШестнадцатеричныхЧисел = МассивШестнадцатеричныхЧисел();
	
	// Обрабатываем данные
	
	СтрокаДанных = "";
	Для Каждого Значение Из МассивДанных Цикл
		СтрокаДанных = СтрокаДанных + МассивШестнадцатеричныхЧисел[Значение];
	КонецЦикла;
	
	ДвоичныеДанные = ПреобразоватьСтрокуДанныхВДвоичныеДанные(СтрокаДанных);
	
	Возврат ДвоичныеДанные;

КонецФункции

&НаКлиенте
Функция МассивШестнадцатеричныхЧисел()

	МассивШестнадцатеричныхЧисел = Новый Массив(256);
	
	Словарь = "0123456789ABCDEF";
	Для Счт1 = 0 По 15 Цикл
		Для Счт2 = 0 По 15 Цикл
			МассивШестнадцатеричныхЧисел[Счт1 * 16 + Счт2] = Сред(Словарь, Счт1 + 1, 1) + Сред(Словарь, Счт2 + 1, 1);
		КонецЦикла;
	КонецЦикла;
	
	Возврат МассивШестнадцатеричныхЧисел;
	
КонецФункции // МассивШестнадцатеричныхЧисел()

&НаКлиенте
Функция ИнициализироватьСтруктуруРезультатаФункции()
	
	СтруктураРезультата = Новый Структура();
	
	СтруктураРезультата.Вставить("Успешно",			Ложь);
	СтруктураРезультата.Вставить("ОписаниеОшибки",	"");
	
	Возврат СтруктураРезультата;
	
КонецФункции

//заполнение

//-------------------------------------------------------------------------------------------------
// Отправка извещений о получении
//-------------------------------------------------------------------------------------------------

&НаКлиенте
Процедура ОтправитьИзвещенияОПолучении() Экспорт
	
	СброситьПроверкиДанныхАвторизации();	
	СформироватьСчетаФактурыДляОтправкиИзвещений();
 
	мРабочийКаталог = КаталогВременныхФайлов();
	Прогресс = 0;
	Всего = СчетаФактурыНаПодписание.Количество();
	ТекОрганизация = Неопределено;
	
	Для каждого СтрокаСЧФ Из СчетаФактурыНаПодписание Цикл
		
		Прогресс = Прогресс + 1;
		ТекПроцент = Цел((Прогресс * 100 / Всего)); 
		Состояние("Отправка извещений в Диадок: " + Прогресс + " из " + Всего, ТекПроцент);
		
		Если ТекОрганизация <> СтрокаСЧФ.Организация Тогда
			
			ТекОрганизация = СтрокаСЧФ.Организация;
			ИнициализироватьДанныеАвторизации(ТекОрганизация);
			ОбновитьДанныеАвторизации("ТипАвторизации", "Сертификат"); 
			
			Если Не СертификатПоОрганизацииНазначен(ТекОрганизация) Тогда
				Продолжить;
			КонецЕсли;
			
			Если Не ДанныеАвторизации.СертификатПроверен Тогда
				
				ПарольКонтейнера = "";
				РезультатПроверки = ПроверитьВыбранныйСертификат(ДанныеАвторизации.Организация, ДанныеАвторизации.Отпечаток, ДанныеАвторизации.СертификатДействуетПо, ПарольКонтейнера);
				
				Если Не ИспользоватьCapicom
					И РезультатПроверки.Успешно = Ложь
					И ОшибкаНеправильныйПарольКонтейнера(РезультатПроверки.ОписаниеОшибки) Тогда
					
					ПарольКонтейнера = ПолучитьПарольКонтейнераСертификатаСервер(ДанныеАвторизации.Организация, ДанныеАвторизации.Отпечаток);
					РезультатПроверки = ПроверитьВыбранныйСертификат(ДанныеАвторизации.Организация, ДанныеАвторизации.Отпечаток, ДанныеАвторизации.СертификатДействуетПо, ПарольКонтейнера);
					
				КонецЕсли;
				
				ОбновитьДанныеАвторизации("СертификатПроверен", Истина);
				
				Если РезультатПроверки.Успешно = Истина Тогда
					ОбновитьДанныеАвторизации("ПарольКонтейнера", ПарольКонтейнера);
					ОбновитьДанныеАвторизации("ВалидацияСертификатаПройдена", Истина);
				Иначе
					ОбновитьДанныеАвторизации("ВалидацияСертификатаПройдена", Ложь);
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
		Если ПропускСертификатаПоОрганизации(ТекОрганизация) Тогда
			Продолжить; 
		КонецЕсли;
		
		СформироватьИОтправитьИзвещенияОПолучении(СтрокаСЧФ.boxId, СтрокаСЧФ.messageId, СтрокаСЧФ.Ссылка, ДанныеАвторизации);
	
	КонецЦикла;
	
	СброситьПарольКонтейнераДанныхАвторизации();
	
КонецПроцедуры

&НаСервере
Процедура СформироватьСчетаФактурыДляОтправкиИзвещений()
	
	СчетаФактурыНаПодписание.Загрузить(МодульОбъекта().ИзвлечьИзВХ("Диадок_ТабСФДляОтправкиИзвещений"));
	
КонецПроцедуры

&НаКлиенте
Процедура СформироватьИОтправитьИзвещенияОПолучении(boxId, messageId, СообщениеСсылка, ДанныеАвторизации)
	
	РезультатПолученияMessage = ПолучитьMessage(boxId, messageId, ДанныеАвторизации);

	Если РезультатПолученияMessage.Успешно = Ложь Тогда
		ТекстСообщения = "Не удалось получить документы из Диадок для формирования извещений";
		МодульОбъектаКлиент().СообщениеПользователю_КонтурEDI(ТекстСообщения);
		Возврат;
	КонецЕсли;
	
	СписокParentEntityIdИзвещенийДляОтправки = ПолучитьСписокParentEntityIdИзвещенийДляОтправки(РезультатПолученияMessage.Значение);
	
	Если СписокParentEntityIdИзвещенийДляОтправки.Количество() = 0 Тогда
		// все извещения уже созданы
		СписокParentEntityIdВсехИзвещений = ПолучитьСписокParentEntityIdВсехИзвещений(РезультатПолученияMessage.Значение);
		Если СписокParentEntityIdВсехИзвещений.Количество() = 0 Тогда
			// пока не можем узнать из статусного EDI с какой функцией (СФ/ДОП) создан документ 
			// поэтому придется подчищать идентификаторы ИОП при обращении в ДД напрямую 
			УдалитьДопРеквизитыСообщенияInvoiceReceiptIdСервер(СообщениеСсылка);
		Иначе
			ЗаписатьДопРеквизитыСообщенияInvoiceReceiptIdСервер(РезультатПолученияMessage.Значение, СписокParentEntityIdВсехИзвещений, СообщениеСсылка);
		КонецЕсли;
		Возврат;
	КонецЕсли;
	
	Receipts = Новый Массив;
	
	Signer = Новый Структура;
	Signer.Вставить("SignerCertificateThumbprint", ДанныеАвторизации.Отпечаток);
	
	Для каждого Эл Из СписокParentEntityIdИзвещенийДляОтправки Цикл
		
		РезультатСозданияИзвещения = GenerateInvoiceDocumentReceiptXml(boxId, messageId, Эл.Значение, ЗаписатьJSONВызовСервера(Signer), ДанныеАвторизации);	
		
		Если РезультатСозданияИзвещения.Успешно Тогда
			
			ПутьКФайлу = СохранитьТекстИзвещенияВФайл(Эл.Значение, РезультатСозданияИзвещения.Значение);
			РезультатПодписанияИзвещения = ПолучитьПодписьФайлаДокумента(ПутьКФайлу, ДанныеАвторизации.Отпечаток, ДанныеАвторизации.ПарольКонтейнера);
			
			Если РезультатПодписанияИзвещения.Успешно Тогда
				
				SignedContent = Новый Структура;
				ДвоичныеДанные = Новый ДвоичныеДанные(ПутьКФайлу);
				SignedContent.Вставить("Content", 	Base64Строка(ДвоичныеДанные));
				SignedContent.Вставить("Signature", РезультатПодписанияИзвещения.ШифрованнаяПодпись);
				
				ReceiptAttachment = Новый Структура;
				ReceiptAttachment.Вставить("ParentEntityId", 	Эл.Значение);
				ReceiptAttachment.Вставить("SignedContent",		SignedContent);
				
				Receipts.Добавить(ReceiptAttachment);
			Иначе
				ТекстСообщения = "Не удалось подписать извещения по причине: " + РезультатПодписанияИзвещения.ОписаниеОшибки;
				МодульОбъектаКлиент().СообщениеПользователю_КонтурEDI(ТекстСообщения);
			КонецЕсли;
			
			УдалитьФайлы(ПутьКФайлу);
		Иначе
			ТекстСообщения = "Не удалось сформировать извещения по причине: " + РезультатСозданияИзвещения.ОписаниеОшибки;
			МодульОбъектаКлиент().СообщениеПользователю_КонтурEDI(ТекстСообщения);
		КонецЕсли;
		
	КонецЦикла;
	
	Если Receipts.Количество() = 0 Тогда
		// не смогли создать/подписать извещения                                   
		Возврат;
	КонецЕсли;
	
	MessagePatchToPost = Новый Структура;
	MessagePatchToPost.Вставить("BoxId", 		boxId);
	MessagePatchToPost.Вставить("MessageId", 	messageId);
	MessagePatchToPost.Вставить("Receipts", 	Receipts);
	
	РезультатОтправки = PostMessagePatch(ЗаписатьJSONВызовСервера(MessagePatchToPost),, ДанныеАвторизации);
	Если РезультатОтправки.Успешно Тогда
		ЗаписатьДопРеквизитыСообщенияInvoiceReceiptIdСервер(РезультатОтправки.Значение, СписокParentEntityIdИзвещенийДляОтправки, СообщениеСсылка);
	Иначе
		ТекстСообщения = "Не удалось отправить извещения по причине: " + РезультатОтправки.ОписаниеОшибки;
		МодульОбъектаКлиент().СообщениеПользователю_КонтурEDI(ТекстСообщения);
		Возврат;
	КонецЕсли;
	
КонецПроцедуры // СформироватьИОтправитьИзвещенияОПолучении()

&НаКлиенте
Функция GenerateInvoiceDocumentReceiptXml(boxId, messageId, attachmentId, RequestBody, ДанныеАвторизации) 
	
	ИспользоватьСохраненныйТокен = Истина;
	
	Для НомерПопытки = 1 По 2 Цикл
		
		Токен = Токен(ДанныеАвторизации, ИспользоватьСохраненныйТокен);
		Ответ = DD_API_GenerateInvoiceDocumentReceiptXml_НаСервере(Токен, boxId, MessageId, attachmentId, RequestBody);
		
		Если Ответ.КодСостояния = "401" 
			И НомерПопытки = 1 Тогда

			ИспользоватьСохраненныйТокен = Ложь;
			Продолжить;
			
		КонецЕсли;
		
		Если Ответ.КодСостояния <> "200" Тогда
			
			ОписаниеОшибки = "Ошибка HTTP запроса"
			+ ?(ЗначениеЗаполнено(Ответ.КодСостояния), Символы.ПС + Ответ.КодСостояния, "")
			+ ?(ЗначениеЗаполнено(Ответ.ТелоОтвета)  , Символы.ПС + Ответ.ТелоОтвета  , "");
			
			ВызватьИсключение ОписаниеОшибки;
			
		КонецЕсли;
		
		Результат = Новый Структура("Успешно,Значение,ОписаниеОшибки",Ложь,Неопределено,"");
		Результат.Успешно = Истина;
		Результат.Значение = Ответ.ТелоОтвета;
		
		Возврат Результат;
		
	КонецЦикла;		
КонецФункции

&НаСервере
Функция DD_API_GenerateInvoiceDocumentReceiptXml_НаСервере(Токен, boxId, MessageId, attachmentId, RequestBody)
	Возврат МодульОбъекта().DD_API_GenerateInvoiceDocumentReceiptXml(Токен, boxId, MessageId, attachmentId, RequestBody);
КонецФункции

&НаСервере
Функция DD_API_PostMessagePatch_НаСервере(Токен, RequestBody, operationId)
	Возврат МодульОбъекта().DD_API_PostMessagePatch(Токен, RequestBody, operationId);
КонецФункции

&НаСервере
Функция DD_API_PrepareDocumentsToSign_НаСервере(Токен, PrepareDocumentsToSignRequest)
	Возврат МодульОбъекта().DD_API_PrepareDocumentsToSign(Токен, PrepareDocumentsToSignRequest);
КонецФункции

&НаСервере
Функция DD_API_SendDraft_НаСервере(Токен, MessagePatchToPost)
	Возврат МодульОбъекта().DD_API_SendDraft(Токен, MessagePatchToPost);
КонецФункции

&НаСервере
Функция DD_API_GetMessage_НаСервере(Токен, BoxId, MessageId)
	Возврат МодульОбъекта().DD_API_GetMessage(Токен, BoxId, MessageId);
КонецФункции

&НаСервере
Функция DD_API_Authenticate_НаСервере(Сертификат = "", Логин = "", Пароль = "")
	Возврат МодульОбъекта().DD_API_Authenticate(Сертификат, Логин, Пароль);
КонецФункции

&НаСервере
Функция DD_API_GetEntityContent_НаСервере(Токен, BoxId, MessageId, EntityId)
	Возврат МодульОбъекта().DD_API_GetEntityContent(Токен, BoxId, MessageId, EntityId);
КонецФункции

&НаСервере
Функция DD_API_GetInvoiceCorrectionRequestInfo_НаСервере(Токен, BoxId, messageId, entityId)
	Возврат МодульОбъекта().DD_API_GetInvoiceCorrectionRequestInfo(Токен, BoxId, messageId, entityId);
КонецФункции
&НаКлиенте
Функция PostMessagePatch(RequestBody, operationId = "", ДанныеАвторизации) 
	
	ИспользоватьСохраненныйТокен = Истина;
	
	Для НомерПопытки = 1 По 2 Цикл
		
		Токен = Токен(ДанныеАвторизации, ИспользоватьСохраненныйТокен);
		Ответ = DD_API_PostMessagePatch_НаСервере(Токен, RequestBody, operationId);
		
		Если Ответ.КодСостояния = "401" 
			И НомерПопытки = 1 Тогда

			ИспользоватьСохраненныйТокен = Ложь;
			Продолжить;

		КонецЕсли;
		
		Если Ответ.КодСостояния <> "200" Тогда
			
			ОписаниеОшибки = "Ошибка HTTP запроса"
			+ ?(ЗначениеЗаполнено(Ответ.КодСостояния), Символы.ПС + Ответ.КодСостояния, "")
			+ ?(ЗначениеЗаполнено(Ответ.ТелоОтвета)  , Символы.ПС + Ответ.ТелоОтвета  , "");
			
			ВызватьИсключение ОписаниеОшибки;
			
		КонецЕсли;
		
		Возврат Новый Структура("Успешно, Значение" , Истина, DoParseВызовСервера(Ответ.ТелоОтвета));
		
	КонецЦикла;	
	
КонецФункции

&НаКлиенте
Функция ПолучитьСписокParentEntityIdВсехИзвещений(Message)
	
	// могут быть AttachmentType: InvoiceConfirmation, InvoiceCorrectionRequest
	СписокParentEntityId = Новый СписокЗначений;
	
	Для каждого Entity Из Message.Entities Цикл
		Если Entity.AttachmentType = "InvoiceConfirmation"
			ИЛИ Entity.AttachmentType = "InvoiceCorrectionRequest" Тогда
			СписокParentEntityId.Добавить(Entity.EntityId, Entity.AttachmentType);
		КонецЕсли;
	КонецЦикла;
	
	Возврат СписокParentEntityId;
	
КонецФункции // ПолучитьСписокParentEntityIdВсехИзвещений()

&НаКлиенте
Функция ПолучитьСписокParentEntityIdИзвещенийДляОтправки(Message)
	
	// могут быть AttachmentType: InvoiceConfirmation, InvoiceCorrectionRequest
	СписокParentEntityId = ПолучитьСписокParentEntityIdВсехИзвещений(Message);
	
	Для каждого Entity Из Message.Entities Цикл
		Если Entity.AttachmentType = "InvoiceReceipt" Тогда
			НайденныйЭлемент = СписокParentEntityId.НайтиПоЗначению(Entity.ParentEntityId);
			Если НЕ НайденныйЭлемент = Неопределено Тогда
				СписокParentEntityId.Удалить(НайденныйЭлемент);	
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат СписокParentEntityId;
	
КонецФункции // ПолучитьСписокParentEntityIdИзвещенийДляОтправки()

&НаКлиенте
Функция СохранитьТекстИзвещенияВФайл(entityId, ТекстИзвещения)
	
	ПутьКФайлу = мРабочийКаталог + entityId;
	ВременныйФайл = Новый Файл(ПутьКФайлу);
	Если ВременныйФайл.Существует() Тогда
		УдалитьФайлы(ВременныйФайл.ПолноеИмя); //Если такой файл уже есть в temp, значит, он остался от предыдущей сессии, когда чо-то пошло не так. Удалим его.
	КонецЕсли;
	ТД = Новый ТекстовыйДокумент;
	ТД.УстановитьТекст(ТекстИзвещения);
	ТД.Записать(ПутьКФайлу, "windows-1251");
	
	Возврат ПутьКФайлу
	
КонецФункции

&НаСервере
Процедура ЗаписатьДопРеквизитыСообщенияInvoiceReceiptIdСервер(MessagePatch, СписокParentEntityId, СообщениеСсылка)
	
	Для каждого Entity Из MessagePatch.Entities Цикл
		Если Entity.AttachmentType = "InvoiceReceipt" Тогда
			
			НайденныйЭлемент = СписокParentEntityId.НайтиПоЗначению(Entity.ParentEntityId);
			Если НЕ НайденныйЭлемент = Неопределено Тогда
				МодульОбъекта().ЗаписатьДопРеквизитСправочника_КонтурEDI(СообщениеСсылка, "InvoiceReceiptEntityId_On" + НайденныйЭлемент.Представление, Entity.EntityId);
			КонецЕсли;
			
		КонецЕсли;
	КонецЦикла;		
	
КонецПроцедуры

&НаСервере
Процедура УдалитьДопРеквизитыСообщенияInvoiceReceiptIdСервер(СообщениеСсылка) 
	
	МодульОбъекта().УдалитьДопРеквизитыСправочника_КонтурEDI(СообщениеСсылка, "InvoiceReceiptEntityId_OnInvoiceConfirmation");
	
КонецПроцедуры

//-------------------------------------------------------------------------------------------------
// Все, что относится к патчу черновиков методом PrepareDocumentsToSign
//-------------------------------------------------------------------------------------------------

&НаКлиенте
Функция ВыполнитьPrepareDocumentsToSign(PrepareDocumentsToSignRequest, ДанныеАвторизации)
	
	ИспользоватьСохраненныйТокен = Истина;
	
	Для НомерПопытки = 1 По 2 Цикл
		
		Токен = Токен(ДанныеАвторизации, ИспользоватьСохраненныйТокен);
		Ответ = DD_API_PrepareDocumentsToSign_НаСервере(Токен, ЗаписатьJSONВызовСервера(PrepareDocumentsToSignRequest));
		
		Если Ответ.КодСостояния = "401" 
			И НомерПопытки = 1 Тогда

			ИспользоватьСохраненныйТокен = Ложь;
			Продолжить;

		КонецЕсли;
		
		Если Ответ.КодСостояния <> "200" Тогда
			
			ТекстОшибки = "Не удалось заполнить подписанта в документе." + Символы.ПС + 
			"Необходимо заполнить раздел ""Сертификаты и полномочия"" в настройках сотрудника в Диадоке, перейти по ссылке:" +
			Символы.ПС + ДиадокСерверAPI_Сервер() + "/" + PrepareDocumentsToSignRequest.BoxId + "/EmployeesList";
			Сообщить(ТекстОшибки);
			Сообщить(Ответ.ТелоОтвета);
			Возврат Неопределено;

			
		КонецЕсли;
		
		Возврат DoParseВызовСервера(Ответ.ТелоОтвета);
		
	КонецЦикла;
			
КонецФункции

&НаКлиенте
Функция НайтиPatchedEntity(PatchedEntities, EntityId)

	Entity = Неопределено;
	
	Для каждого PatchedEntity Из PatchedEntities Цикл
		Если PatchedEntity.DocumentId.EntityId = EntityId Тогда
			Entity = PatchedEntity;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
    Возврат Entity;
	
КонецФункции

&НаКлиенте
Функция ПодписатьPatchedEntity(PatchedEntity, МассивСтруктур, ДанныеАвторизации)
	
	Результат = ИнициализироватьСтруктуруРезультатаФункции();
	
	ПутьКФайлу = мРабочийКаталог + PatchedEntity.DocumentId.EntityId;
	ВременныйФайл = Новый Файл(ПутьКФайлу);
	Если ВременныйФайл.Существует() Тогда
		УдалитьФайлы(ВременныйФайл.ПолноеИмя); //Если такой файл уже есть в temp, значит, он остался от предыдущей сессии, когда чо-то пошло не так. Удалим его.
	КонецЕсли;
	Base64Значение(PatchedEntity.Content).Записать(ПутьКФайлу);

	РезультатПодписания = ПолучитьПодписьФайлаДокумента(ПутьКФайлу, ДанныеАвторизации.Отпечаток, ДанныеАвторизации.ПарольКонтейнера);
	
	Если Не РезультатПодписания.Успешно Тогда
		Результат.ОписаниеОшибки = РезультатПодписания.ОписаниеОшибки;
		Возврат Результат;
	Иначе
		Результат.Успешно = Истина;
	КонецЕсли;
	
	Signature = РезультатПодписания.ШифрованнаяПодпись;

	DocumentSignature = Новый Структура;
	DocumentSignature.Вставить("ParentEntityId", 	PatchedEntity.DocumentId.EntityId);
	DocumentSignature.Вставить("Signature",			Signature);
	DocumentSignature.Вставить("PatchedContentId",	PatchedEntity.PatchedContentId);
	
	МассивСтруктур.Добавить(DocumentSignature);

	Возврат Результат;
	
КонецФункции

&НаКлиенте
Функция ПолучитьEntitiesДляПодписания(MessageЧерновик)
	
	EntitiesДляПодписания = Новый Массив;
	
	Для каждого EntityЧерновика Из MessageЧерновик.Значение.Entities Цикл
		Если EntityЧерновика.Свойство("DocumentInfo") Тогда 
			EntitiesДляПодписания.Добавить(EntityЧерновика);
        КонецЕсли;
	КонецЦикла;
	
	Возврат EntitiesДляПодписания;
	
КонецФункции

&НаКлиенте
Функция ПолучитьPatchedEntities(EntitiesДляПатча, СчетФактураКПодписи, ДанныеАвторизации, IsDraft)
	
	PrepareDocumentsToSignRequest = Новый Структура;
	PrepareDocumentsToSignRequest.Вставить("BoxId", СчетФактураКПодписи.boxId);

   	МассивDocumentToPatch = Новый Массив;
	
	Для каждого Entity Из EntitiesДляПатча Цикл
		
		DocumentToPatch = Новый Структура("DocumentId,ExtendedSigner,Signer");
		
		DocumentToPatch.DocumentId = Новый Структура("MessageId,EntityId", СчетФактураКПодписи.messageId, Entity.EntityId);
			
		ЭтоУПД = Найти(Entity.Version, "utd") > 0 ИЛИ Найти(Entity.Version, "ucd") > 0;			
		
		Если ЭтоУПД Тогда			
			DocumentToPatch.ExtendedSigner = Новый Массив; 			
			DocumentToPatch.ExtendedSigner.Добавить(Новый Структура("BoxId,SignerCertificateThumbprint", СчетФактураКПодписи.boxId, ДанныеАвторизации.Отпечаток)); 						
		Иначе 			
			DocumentToPatch.Signer = Новый Структура("SignerCertificateThumbprint", ДанныеАвторизации.Отпечаток);						
		КонецЕсли;
			
		МассивDocumentToPatch.Добавить(DocumentToPatch); 	
		
	КонецЦикла;
	
	ИмяСтруктуры = ?(isDraft, "DraftDocuments", "Documents");
	
	PrepareDocumentsToSignRequest.Вставить(ИмяСтруктуры, МассивDocumentToPatch); 
	
	Результат = ВыполнитьPrepareDocumentsToSign(PrepareDocumentsToSignRequest, ДанныеАвторизации);	
	
	Если Результат = Неопределено Тогда
		Возврат Новый Массив;
	Иначе
		Возврат Результат.DocumentPatchedContents;
	КонецЕсли; 
		
КонецФункции

//-------------------------------------------------------------------------------------------------
//обработка выполнения http-запросов  -------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

&НаКлиенте
Процедура ЗарегистрироватьОшибкуАвторизации(Организация,ОписаниеОшибки)

	//получить токен, повторно авторизовавшись

КонецПроцедуры // ЗарегистрироватьОшибкуАвторизации()

&НаКлиенте
Функция ОшибкаАвторизацииПоHttpКодуВозврата(ИмяРесурса,HttpКодВозврата)
	
	ОшибкаАвторизации = Ложь;
	Возврат "401"=HttpКодВозврата;
	
	//// по хорошему надо так:
	ПодготовитьТаблицуHttpКодовВозврата();
			
	Отбор = Новый Структура("ИмяРесурса,HttpКодВозврата",ИмяРесурса,HttpКодВозврата);
	МассивСтрок = HttpКодыВозвратаAPI.НайтиСтроки(Отбор);
	Если Не МассивСтрок.Количество() = 0 Тогда
		Строка = МассивСтрок[0];
		ОшибкаАвторизации = Строка.ОшибкаАвторизации;
	КонецЕсли;
	 
	Возврат ОшибкаАвторизации;
			
КонецФункции

&НаКлиенте
Процедура ДобавитьДанныеHttpКодаВозврата(Массив,ИмяРесурса,HttpКодВозврата,ОшибкаАвторизации,Описание)
	
	Данные = Новый Структура;
	Данные.Вставить("ИмяРесурса",		ИмяРесурса);
	Данные.Вставить("HttpКодВозврата",	HttpКодВозврата);
	Данные.Вставить("ОшибкаАвторизации",ОшибкаАвторизации);
	Данные.Вставить("Описание",			Описание);
	
	Массив.Добавить(Данные);
	
КонецПроцедуры

&НаКлиенте
Процедура ПодготовитьТаблицуHttpКодовВозврата()
	
	Если Не HttpКодыВозвратаAPI = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	HttpКодыВозвратаAPI = Новый Массив;
	
	// Authenticate
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/Authenticate",	200,Ложь,  "операция успешно завершена");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/Authenticate",	400,Ложь,  "данные в запросе имеют неверный формат или отсутствуют обязательные параметры");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/Authenticate",	401,Истина,"в запросе отсутствует HTTP-заголовок Authorization, или в этом заголовке отсутствует параметр ddauth_api_client_id, или переданный в нем ключ разработчика не зарегистрирован в Диадоке");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/Authenticate",	405,Ложь,  "используется неподходящий HTTP-метод");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/Authenticate",	500,Ложь,  "при обработке запроса возникла непредвиденная ошибка");
	
	// SendDraft
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/SendDraft",	200,Ложь,  "операция успешно завершена");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/SendDraft",	400,Ложь,  "данные в запросе имеют неверный формат или отсутствуют обязательные параметры");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/SendDraft",	401,Истина,"в запросе отсутствует HTTP-заголовок Authorization, или в этом заголовке содержатся некорректные авторизационные данные");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/SendDraft",	403,Ложь,  "доступ к ящику с предоставленным авторизационным токеном запрещен");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/SendDraft",	405,Ложь,  "используется неподходящий HTTP-метод");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/SendDraft",	409,Ложь,  "попытка отправить дубликат сообщения, либо указан несуществующий идентификатор содержимого документа, подготовленного к отправке (см. PrepareDocumentsToSign), либо запрещен прием документов от контрагентов согласно свойству Sociability из Organization.");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/SendDraft",	500,Ложь,  "при обработке запроса возникла непредвиденная ошибка");
	
	// PrepareDocumentsToSign
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/PrepareDocumentsToSign",	200,Ложь,  "операция успешно завершена");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/PrepareDocumentsToSign",	400,Ложь,  "данные в запросе имеют неверный формат");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/PrepareDocumentsToSign",	401,Истина,"в запросе отсутствует HTTP-заголовок Authorization, или в этом заголовке содержатся некорректные авторизационные данные");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/PrepareDocumentsToSign",	403,Ложь,  "указанный в PrepareDocumentsToSignRequest.BoxId ящик не существует, либо у пользователя отсутствует доступ к ящику, либо у пользователя отсутствует доступ к документу");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/PrepareDocumentsToSign",	405,Ложь,  "используется неподходящий HTTP-метод");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/PrepareDocumentsToSign",	500,Ложь,  "при обработке запроса возникла непредвиденная ошибка");
	
	// GetMessage
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V3/GetMessage",	200,Ложь,  "операция успешно завершена");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V3/GetMessage",	400,Ложь,  "данные в запросе имеют неверный формат или отсутствуют обязательные параметры");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V3/GetMessage",	401,Истина,"в запросе отсутствует HTTP-заголовок Authorization, или в этом заголовке содержатся некорректные авторизационные данные");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V3/GetMessage",	403,Ложь,  "доступ к ящику с предоставленным авторизационным токеном запрещен");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V3/GetMessage",	404,Ложь,  "в указанном ящике нет сообщений с данным идентификатором");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V3/GetMessage",	405,Ложь,  "используется неподходящий HTTP-метод");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V3/GetMessage",	500,Ложь,  "при обработке запроса возникла непредвиденная ошибка");
	
	// GetEntityContent
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V4/GetEntityContent",	200,Ложь,  "операция успешно завершена");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V4/GetEntityContent",	400,Ложь,  "данные в запросе имеют неверный формат или отсутствуют обязательные параметры");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V4/GetEntityContent",	401,Истина,"в запросе отсутствует HTTP-заголовок Authorization, или в этом заголовке содержатся некорректные авторизационные данные");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V4/GetEntityContent",	403,Ложь,  "доступ к ящику с предоставленным авторизационным токеном запрещен");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V4/GetEntityContent",	404,Ложь,  "в указанном ящике нет сообщения с идентификатором messageId, либо в указанном сообщении нет сущности с идентификатором entityId");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V4/GetEntityContent",	405,Ложь,  "используется неподходящий HTTP-метод");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V4/GetEntityContent",	500,Ложь,  "при обработке запроса возникла непредвиденная ошибка");
	
	// PostMessagePatch
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V3/PostMessagePatch",	200,Ложь,  "операция успешно завершена");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V3/PostMessagePatch",	400,Ложь,  "данные в запросе имеют неверный формат или отсутствуют обязательные параметры");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V3/PostMessagePatch",	401,Истина,"в запросе отсутствует HTTP-заголовок Authorization, или в этом заголовке содержатся некорректные авторизационные данные");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V3/PostMessagePatch",	403,Ложь,  "доступ к ящику с предоставленным авторизационным токеном запрещен");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V3/PostMessagePatch",	405,Ложь,  "используется неподходящий HTTP-метод");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V3/PostMessagePatch",	409,Ложь,  "попытка отправить дубликат сообщения или запрет приема документов от контрагентов согласно свойству Sociability из Organization");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V3/PostMessagePatch",	500,Ложь,  "при обработке запроса возникла непредвиденная ошибка");
	
	// GenerateInvoiceDocumentReceiptXml
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/GenerateInvoiceDocumentReceiptXml",	200,Ложь,  "операция успешно завершена");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/GenerateInvoiceDocumentReceiptXml",	400,Ложь,  "данные в запросе имеют неверный формат или отсутствуют обязательные параметры");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/GenerateInvoiceDocumentReceiptXml",	401,Истина,"в запросе отсутствует HTTP-заголовок Authorization, или в этом заголовке содержатся некорректные авторизационные данные");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/GenerateInvoiceDocumentReceiptXml",	403,Ложь,  "доступ к ящику с предоставленным авторизационным токеном запрещен");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/GenerateInvoiceDocumentReceiptXml",	404,Ложь,  "в указанном ящике нет сообщения с идентификатором messageId, либо в указанном сообщении нет сущности с идентификатором attachmentId");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/GenerateInvoiceDocumentReceiptXml",	405,Ложь,  "используется неподходящий HTTP-метод");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/GenerateInvoiceDocumentReceiptXml",	409,Ложь,  "формирование извещения о получении для данного документа невозможно");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/GenerateInvoiceDocumentReceiptXml",	500,Ложь,  "при обработке запроса возникла непредвиденная ошибка");
	
КонецПроцедуры

&НаКлиенте
Функция ОписаниеHttpКодаВозврата(ИмяРесурса,HttpКодВозврата)
	
	Описание = "";
	СтруктураHttpКодаВозврата = Неопределено;
	
	ПодготовитьТаблицуHttpКодовВозврата();
	
	Для Каждого Структура Из HttpКодыВозвратаAPI Цикл
		Если Не Структура.ИмяРесурса = ИмяРесурса или
			 Не Структура.HttpКодВозврата = HttpКодВозврата Тогда
			Продолжить;			
		КонецЕсли;
		СтруктураHttpКодаВозврата = Структура;
	КонецЦикла;
	
	Если Не СтруктураHttpКодаВозврата = Неопределено Тогда
		Описание = СтруктураHttpКодаВозврата.Описание;
	КонецЕсли;
	
	Возврат Описание;
	
КонецФункции
  
//-------------------------------------------------------------------------------------------------
//авторизация на сервере Диадока ------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

&НаКлиенте
Функция КлючАвторизацииAPI()
	
	Возврат API_КлючРазработчика_Диадок_Сервер();
		
КонецФункции

&НаСервере
Функция API_КлючРазработчика_Диадок_Сервер()
	Возврат МодульОбъекта().API_КлючРазработчика_Диадок();
КонецФункции

&НаКлиенте
Функция Токен(ДанныеАвторизации, ИспользоватьКэш = Истина) Экспорт
	
    Токен = Неопределено;
	
	Если ДанныеАвторизации.ТипАвторизации = "ЛогинПароль" Тогда
		Ключ = ДанныеАвторизации.ЛогинДД;		
	ИначеЕсли ДанныеАвторизации.ТипАвторизации = "Сертификат" Тогда
		Ключ = ДанныеАвторизации.Отпечаток;	
	КонецЕсли;
	
	Если Токены = Неопределено Тогда
		Токены = Новый Соответствие;
	КонецЕсли;
	
	Если ИспользоватьКэш Тогда	
		//Токены = ИзвлечьИзВХ("Токены"); 
		Если Не Токены = Неопределено Тогда
			Токен = Токены.Получить(Ключ);
		КонецЕсли;
	КонецЕсли;
		
	Если Токен = Неопределено Тогда
		
		Состояние("Авторизация в Диадок...");
		
		Если ДанныеАвторизации.ТипАвторизации = "ЛогинПароль" Тогда
			
			Ответ = DD_API_Authenticate_НаСервере(, ДанныеАвторизации.ЛогинДД, ДанныеАвторизации.ПарольДД);
			
			Если Ответ.КодСостояния <> "200" Тогда
				
				ОписаниеОшибки = "Ошибка HTTP запроса"
				+ ?(ЗначениеЗаполнено(Ответ.КодСостояния), Символы.ПС + Ответ.КодСостояния, "")
				+ ?(ЗначениеЗаполнено(Ответ.ТелоОтвета)  , Символы.ПС + Ответ.ТелоОтвета  , "");
				
				ВызватьИсключение ОписаниеОшибки;
				
			КонецЕсли;
			
			Токен = Ответ.ТелоОтвета;
			
		ИначеЕсли ДанныеАвторизации.ТипАвторизации = "Сертификат" Тогда
			
			Если ИспользоватьCapicom Тогда
				ТелоЗапроса = ПолучитьСертификатCapicom(ДанныеАвторизации.Отпечаток,0);
			Иначе
				ТелоЗапроса = ПолучитьСертификат1СПоОтпечатку(ДанныеАвторизации.Отпечаток, Истина);
			КонецЕсли;
			
			Ответ = DD_API_Authenticate_НаСервере(ТелоЗапроса);
			
			Если Ответ.КодСостояния <> "200" Тогда
				
				ОписаниеОшибки = "Ошибка HTTP запроса"
				+ ?(ЗначениеЗаполнено(Ответ.КодСостояния), Символы.ПС + Ответ.КодСостояния, "")
				+ ?(ЗначениеЗаполнено(Ответ.ТелоОтвета)  , Символы.ПС + Ответ.ТелоОтвета  , "");
				
				ВызватьИсключение ОписаниеОшибки;
				
			КонецЕсли;
			
			Токен = РасшифроватьЗашифрованныйТокен(Ответ.ТелоОтвета, ДанныеАвторизации.ПарольКонтейнера);

		КонецЕсли;

		Токены.Вставить(Ключ, Токен);

		Состояние("");
	
	КонецЕсли;
	
	Возврат Токен;
	
КонецФункции


//-------------------------------------------------------------------------------------------------
//криптография ------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

&НаКлиенте
Функция ПолучитьТипыМодуляКриптографии()
	
	КриптоПроГОСТ2001 = Новый Структура("ИмяМодуляКриптографии, ТипМодуляКриптографии, ПутьМодуляКриптографии");
	КриптоПроГОСТ2001.Вставить("ТипМодуляКриптографии", 75);
	КриптоПроГОСТ2001.Вставить("ИмяМодуляКриптографии", "Crypto-Pro GOST R 34.10-2001 Cryptographic Service Provider");
	КриптоПроГОСТ2001.Вставить("ПутьМодуляКриптографии", "");
	
	КриптоПроГОСТ2012 = Новый Структура("ИмяМодуляКриптографии, ТипМодуляКриптографии, ПутьМодуляКриптографии");
	КриптоПроГОСТ2012.Вставить("ТипМодуляКриптографии", 80);
	КриптоПроГОСТ2012.Вставить("ИмяМодуляКриптографии", "Crypto-Pro GOST R 34.10-2012 Cryptographic Service Provider");
	КриптоПроГОСТ2012.Вставить("ПутьМодуляКриптографии", "");
	
	КриптоПроГОСТ2012Усиленый = Новый Структура("ИмяМодуляКриптографии, ТипМодуляКриптографии, ПутьМодуляКриптографии");
	КриптоПроГОСТ2012Усиленый.Вставить("ТипМодуляКриптографии", 81);
	КриптоПроГОСТ2012Усиленый.Вставить("ИмяМодуляКриптографии", "Crypto-Pro GOST R 34.10-2012 Strong Cryptographic Service Provider");
	КриптоПроГОСТ2012Усиленый.Вставить("ПутьМодуляКриптографии", "");
	
	КриптоПроФКН = Новый Структура("ИмяМодуляКриптографии, ТипМодуляКриптографии, ПутьМодуляКриптографии");
	КриптоПроФКН.Вставить("ТипМодуляКриптографии", 75);
	КриптоПроФКН.Вставить("ИмяМодуляКриптографии", "GOST R 34.10-2001 eToken CSP");
	КриптоПроФКН.Вставить("ПутьМодуляКриптографии", "");
	
	КриптоПроРутокен = Новый Структура("ИмяМодуляКриптографии, ТипМодуляКриптографии, ПутьМодуляКриптографии");
	КриптоПроРутокен.Вставить("ТипМодуляКриптографии", 75);
	КриптоПроРутокен.Вставить("ИмяМодуляКриптографии", "GOST R 34.10-2001 Rutoken CSP");
	КриптоПроРутокен.Вставить("ПутьМодуляКриптографии", "");
	
	ВИПНетГОСТ2001 = Новый Структура("ИмяМодуляКриптографии, ТипМодуляКриптографии, ПутьМодуляКриптографии");		
	ВИПНетГОСТ2001.Вставить("ТипМодуляКриптографии", 2);
	ВИПНетГОСТ2001.Вставить("ИмяМодуляКриптографии", "Infotecs Cryptographic Service Provider");
	ВИПНетГОСТ2001.Вставить("ПутьМодуляКриптографии", "");
	
	ВИПНетГОСТ2012 = Новый Структура("ИмяМодуляКриптографии, ТипМодуляКриптографии, ПутьМодуляКриптографии");		
	ВИПНетГОСТ2012.Вставить("ТипМодуляКриптографии", 77);
	ВИПНетГОСТ2012.Вставить("ИмяМодуляКриптографии", "Infotecs GOST 2012/512 Cryptographic Service Provider");
	ВИПНетГОСТ2012.Вставить("ПутьМодуляКриптографии", "");
	
	ВИПНетГОСТ2012Усиленый = Новый Структура("ИмяМодуляКриптографии, ТипМодуляКриптографии, ПутьМодуляКриптографии");		
	ВИПНетГОСТ2012Усиленый.Вставить("ТипМодуляКриптографии", 78);
	ВИПНетГОСТ2012Усиленый.Вставить("ИмяМодуляКриптографии", "Infotecs GOST 2012/1024 Cryptographic Service Provider");
	ВИПНетГОСТ2012Усиленый.Вставить("ПутьМодуляКриптографии", "");
	
	КриптоПроГОСТ34_10_2001_Linux_x64 = Новый Структура("ИмяМодуляКриптографии, ТипМодуляКриптографии, ПутьМодуляКриптографии");		
	КриптоПроГОСТ34_10_2001_Linux_x64.Вставить("ТипМодуляКриптографии", 75);
	КриптоПроГОСТ34_10_2001_Linux_x64.Вставить("ИмяМодуляКриптографии", "Crypto-Pro GOST R 34.10-2001 KC1 CSP");
	КриптоПроГОСТ34_10_2001_Linux_x64.Вставить("ПутьМодуляКриптографии", "/opt/cprocsp/lib/amd64/libcapi20.so");
	
	КриптоПроГОСТ34_10_2001_Linux_x32 = Новый Структура("ИмяМодуляКриптографии, ТипМодуляКриптографии, ПутьМодуляКриптографии");		
	КриптоПроГОСТ34_10_2001_Linux_x32.Вставить("ТипМодуляКриптографии", 75);
	КриптоПроГОСТ34_10_2001_Linux_x32.Вставить("ИмяМодуляКриптографии", "Crypto-Pro GOST R 34.10-2001 KC1 CSP");
	КриптоПроГОСТ34_10_2001_Linux_x32.Вставить("ПутьМодуляКриптографии", "/opt/cprocsp/lib/ia32/libcapi20.so");

	ПоддерживаемыеТипы = Новый Массив;
	ПоддерживаемыеТипы.Добавить(КриптоПроГОСТ2012);
	ПоддерживаемыеТипы.Добавить(КриптоПроГОСТ2001);	
	ПоддерживаемыеТипы.Добавить(КриптоПроГОСТ2012Усиленый);
	ПоддерживаемыеТипы.Добавить(КриптоПроФКН);
	ПоддерживаемыеТипы.Добавить(КриптоПроРутокен);
	ПоддерживаемыеТипы.Добавить(ВИПНетГОСТ2012);
	ПоддерживаемыеТипы.Добавить(ВИПНетГОСТ2001);
	ПоддерживаемыеТипы.Добавить(ВИПНетГОСТ2012Усиленый);
	ПоддерживаемыеТипы.Добавить(КриптоПроГОСТ34_10_2001_Linux_x64);
	ПоддерживаемыеТипы.Добавить(КриптоПроГОСТ34_10_2001_Linux_x32);
	
	Возврат ПоддерживаемыеТипы;
	
КонецФункции

&НаСервере
Функция ПолучитьПарольКонтейнераСертификатаСервер(Организация, Отпечаток)

	Возврат МодульОбъекта().ПолучитьПарольКонтейнераСертификата(Организация, Отпечаток);
	
КонецФункции // ПолучитьПарольКонтейнераСертификатаСервер()

&НаСервере
Процедура СохранитьПараметрыСертификатаСервер(ДанныеСертификата)

	МодульОбъекта().СохранитьПараметрыСертификата(ДанныеСертификата);
	
КонецПроцедуры // СохранитьПараметрыСертификатаСервер()

&НаКлиенте
Функция МенеджерКриптографии1С(ПарольКонтейнера = "")
	
	ИмяМодуляКриптографии   = ДанныеАвторизации.ИмяМодуляКриптографии;
	ТипМодуляКриптографии	= ДанныеАвторизации.ТипМодуляКриптографии;
	ПутьМодуляКриптографии 	= "";

	Для Каждого МодульКриптографии Из ПолучитьТипыМодуляКриптографии() Цикл
		
		Попытка
			МенеджерКриптографии1С = Новый МенеджерКриптографии(ИмяМодуляКриптографии, ПутьМодуляКриптографии, ТипМодуляКриптографии);
		Исключение
			ИмяМодуляКриптографии   = МодульКриптографии.ИмяМодуляКриптографии;
			ТипМодуляКриптографии	= МодульКриптографии.ТипМодуляКриптографии;
			ПутьМодуляКриптографии  = МодульКриптографии.ПутьМодуляКриптографии;
			_ОписаниеОшибки = ОписаниеОшибки();
			Продолжить;
		КонецПопытки;
		
		ОбновитьДанныеАвторизации("ИмяМодуляКриптографии", ИмяМодуляКриптографии);
		ОбновитьДанныеАвторизации("ТипМодуляКриптографии", ТипМодуляКриптографии);
		
		МенеджерКриптографии1С.ПарольДоступаКЗакрытомуКлючу = ПарольКонтейнера;
		
		Возврат МенеджерКриптографии1С;
		
	КонецЦикла;
	
	ВызватьИсключение "Не удалось инициализировать менеджер криптографии по причине:
						|" + _ОписаниеОшибки;
	
КонецФункции

&НаКлиенте
Функция ШаблонРеквизитовСертификата()
	
	Структура = Новый Структура;
	Структура.Вставить("НаименованиеОрганизацииСубъекта",	"");
	Структура.Вставить("НаименованиеСубъекта",				"");
	Структура.Вставить("НачалоПериодаДействия",				Дата(1,1,1));
	Структура.Вставить("ОкончаниеПериодаДействия",			Дата(1,1,1));
	Структура.Вставить("НаименованиеУдостоверяющегоЦентра",	"");
	Структура.Вставить("Отпечаток",							"");
	Структура.Вставить("Расположение",						"клиент"); // отличет от серверного метода
	Структура.Вставить("ПарольКонтейнера",					""); 
	
	Возврат Структура;
	
КонецФункции

&НаКлиенте
Функция ПолучитьРеквизитыСертификата(Отпечаток) Экспорт
	
	РеквизитыСертификата = Неопределено;	
	
	Попытка 
		
		Если ИспользоватьCapicom Тогда
			
			КоллекцияСертификатовХранилища = ХранилищеСертификатовCapicom().Certificates;
			КоличествоСертификатовХранилища = КоллекцияСертификатовХранилища.Count;
			
			Для Индекс = 1 По КоличествоСертификатовХранилища Цикл
				
				Сертификат = КоллекцияСертификатовХранилища.Item(Индекс);
				Если Не Сертификат.Thumbprint = Отпечаток Тогда
					Продолжить;
				КонецЕсли;
				
				РеквизитыСертификата = ПолучитьРеквизитыCOMОбъектаСертификата(Сертификат);
				Прервать;
				
			КонецЦикла;
			
		Иначе
			
			Сертификат = ПолучитьСертификат1СПоОтпечатку(Отпечаток);
			РеквизитыСертификата = ПолучитьРеквизиты1ССертификата(Сертификат);

		КонецЕсли;

	Исключение
		_ОписаниеОшибки = ОписаниеОшибки();
	КонецПопытки;
	
	Возврат РеквизитыСертификата;
	
КонецФункции

&НаКлиенте
Функция ПолучитьРеквизиты1ССертификата(Сертификат)
	
	РеквизитыСертификата = ШаблонРеквизитовСертификата();
	
	НаименованиеОрганизацииСубъекта	= "";
	Если Сертификат.Субъект.Свойство("O") Тогда
		НаименованиеОрганизацииСубъекта = Сертификат.Субъект.O;
	КонецЕсли;
	
	НаименованиеСубъекта = "";
	Если Сертификат.Субъект.Свойство("SN") 
		И Сертификат.Субъект.Свойство("GN") Тогда
		НаименованиеСубъекта = Сертификат.Субъект.SN + " " + Сертификат.Субъект.GN;
	ИначеЕсли Сертификат.Субъект.Свойство("SN") 
		И Сертификат.Субъект.Свойство("G") Тогда
		НаименованиеСубъекта = Сертификат.Субъект.SN + " " + Сертификат.Субъект.G;
	ИначеЕсли Сертификат.Субъект.Свойство("CN") Тогда
		НаименованиеСубъекта = Сертификат.Субъект.CN;
	КонецЕсли;
		
	НаименованиеУдостоверяющегоЦентра = ""; 
	Если Сертификат.Издатель.Свойство("O") Тогда
		НаименованиеУдостоверяющегоЦентра = Сертификат.Издатель.O;
	ИначеЕсли Сертификат.Издатель.Свойство("CN") Тогда
		НаименованиеУдостоверяющегоЦентра = Сертификат.Издатель.CN;
	КонецЕсли;
	
	РеквизитыСертификата.НаименованиеОрганизацииСубъекта 	= НаименованиеОрганизацииСубъекта;
	РеквизитыСертификата.НаименованиеСубъекта 				= НаименованиеСубъекта;
	РеквизитыСертификата.НачалоПериодаДействия 				= Сертификат.ДатаНачала;
	РеквизитыСертификата.ОкончаниеПериодаДействия 			= Сертификат.ДатаОкончания;
	РеквизитыСертификата.НаименованиеУдостоверяющегоЦентра 	= НаименованиеУдостоверяющегоЦентра;
	РеквизитыСертификата.Отпечаток 							= СтрЗаменить(Строка(Сертификат.Отпечаток), " ", "");
	
	Возврат РеквизитыСертификата;	
	
КонецФункции

&НаКлиенте
Функция МассивСертификатов(ТолькоДействующие = Истина) Экспорт
	
	// TODO тут легаси, надо прибраться
	Если ДанныеАвторизации = Неопределено Тогда
		ДанныеАвторизации = ПолучитьСтруктуруДанныхАвторизации();
	КонецЕсли;
	
	// вернет массив действующих сертификатов
	МассивСертификатов = Новый Массив;
			
	Попытка 
		
		Если ИспользоватьCapicom Тогда
			
			КоллекцияСертификатовХранилища = ХранилищеСертификатовCapicom().Certificates;
			КоличествоСертификатовХранилища = КоллекцияСертификатовХранилища.Count;
			
			Для Индекс = 1 По КоличествоСертификатовХранилища Цикл
				Сертификат = КоллекцияСертификатовХранилища.Item(Индекс);
				
				Если ТолькоДействующие
					И КонецДня(Сертификат.ValidToDate()) < ТекущаяДата() Тогда
					Продолжить;
				КонецЕсли;
				
				РеквизитыСертификата = ПолучитьРеквизитыCOMОбъектаСертификата(Сертификат);
				МассивСертификатов.Добавить(РеквизитыСертификата);
			КонецЦикла;
			
		Иначе
			
			КоллекцияСертификатовХранилища = ХранилищеСертификатов1С().ПолучитьВсе();
			
			Для каждого Сертификат Из КоллекцияСертификатовХранилища Цикл
				
				Если Сертификат.ИспользоватьДляПодписи = Ложь 
					ИЛИ Сертификат.ИспользоватьДляШифрования = Ложь Тогда
					Продолжить;	
				КонецЕсли;

				Если ТолькоДействующие
					И КонецДня(Сертификат.ДатаОкончания) < ТекущаяДата() Тогда
					Продолжить;
				КонецЕсли;
				
				РеквизитыСертификата = ПолучитьРеквизиты1ССертификата(Сертификат);
				МассивСертификатов.Добавить(РеквизитыСертификата);
			КонецЦикла;
			
		КонецЕсли;

	Исключение
		_ОписаниеОшибки = ОписаниеОшибки();
		Возврат МассивСертификатов;
	КонецПопытки;
		
	Возврат МассивСертификатов;
	
КонецФункции

&НаКлиенте
Функция ПолучитьРеквизитыCOMОбъектаСертификата(COMОбъектСертификата)
	
	РеквизитыСертификата = ШаблонРеквизитовСертификата();
	
	МассивДанныхУЦ = РазложитьСтрокуВМассивСлов_КонтурСВ(COMОбъектСертификата.IssuerName,",");
	Для Каждого Элемент Из МассивДанныхУЦ Цикл
		Если Найти(Элемент,"O=")>0 Тогда 
			НаименованиеУдостоверяющегоЦентра = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Элемент,"O=",""),"""""","|"),"""",""),"|","""");
		КонецЕсли;
	КонецЦикла;
	
	НаименованиеСубъекта = "";
	НаименованиеОрганизацииСубъекта = "";
	МассивДанныхСубъекта = РазложитьСтрокуВМассивСлов_КонтурСВ(COMОбъектСертификата.SubjectName,",");
	Для Каждого Элемент Из МассивДанныхСубъекта Цикл
		Если Найти(Элемент,"CN=")>0 Тогда
			НаименованиеСубъекта = СтрЗаменить(Элемент,"CN=",""); 			
		ИначеЕсли Найти(Элемент,"O=")>0 Тогда 
			НаименованиеОрганизацииСубъекта = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Элемент,"O=",""),"""""","|"),"""",""),"|","""");
		КонецЕсли;
	КонецЦикла;
	
	РеквизитыСертификата.НаименованиеОрганизацииСубъекта = НаименованиеОрганизацииСубъекта;
	РеквизитыСертификата.НаименованиеСубъекта = НаименованиеСубъекта;
	РеквизитыСертификата.НачалоПериодаДействия = COMОбъектСертификата.ValidFromDate;
	РеквизитыСертификата.ОкончаниеПериодаДействия = COMОбъектСертификата.ValidToDate;
	РеквизитыСертификата.НаименованиеУдостоверяющегоЦентра = НаименованиеУдостоверяющегоЦентра;
	РеквизитыСертификата.Отпечаток = COMОбъектСертификата.Thumbprint;
	
	Возврат РеквизитыСертификата;	
		
КонецФункции

&НаКлиенте
Функция ПолучитьСертификатCapicom(Отпечаток, ЭкспортСертификата=0)
	
	Если КэшСертификатов = Неопределено Тогда
		КэшСертификатов = Новый Соответствие;
	КонецЕсли;
	
	ТекСертификат = КэшСертификатов.Получить(Отпечаток);
	Попытка
						
		ПолученныеСертификаты = ХранилищеСертификатовCapicom();
		Если ПолученныеСертификаты = неопределено Тогда
			Возврат неопределено;
		Иначе
			Если ЭкспортСертификата = 3 Тогда //возвращает сертификат
				ТекСертификат = ПолученныеСертификаты.Certificates.Find(0, Отпечаток).Item(1); //0 - CAPICOM_CERTIFICATE_FIND_SHA1_HASH
			Иначе //экспорт сертификата 0 - Base64, 1 - DER (двоичные данные)
				ТекСертификат = ПолученныеСертификаты.Certificates.Find(0, Отпечаток).Item(1).Export(ЭкспортСертификата); //0 - CAPICOM_CERTIFICATE_FIND_SHA1_HASH	
			КонецЕсли;
		КонецЕсли;
		
		Если НЕ ТекСертификат = Неопределено Тогда
			КэшСертификатов.Вставить(Отпечаток, ТекСертификат);
		КонецЕсли;
	Исключение
		_ОписаниеОшибки = ОписаниеОшибки();
	КонецПопытки;
	
	Возврат ТекСертификат;
	
КонецФункции

&НаКлиенте
Функция ПолучитьСертификат1СПоОтпечатку(Отпечаток, ЭкспортСертификата = Ложь)
	
	Если КэшСертификатов = Неопределено Тогда
		КэшСертификатов = Новый Соответствие;
	КонецЕсли;
	
	ТекСертификат = КэшСертификатов.Получить(Отпечаток);
	Если ТекСертификат = Неопределено Тогда
		
		ДвоичныеДанныеОтпечатка = ПреобразоватьСтрокуДанныхВДвоичныеДанные(Отпечаток);
		
		ТекСертификат = ХранилищеСертификатов1С().НайтиПоОтпечатку(ДвоичныеДанныеОтпечатка);
		Если НЕ ТекСертификат = Неопределено Тогда
			КэшСертификатов.Вставить(Отпечаток, ТекСертификат);
		КонецЕсли;
		
	КонецЕсли;
	
	Если ЭкспортСертификата = Ложь Тогда
		Возврат ТекСертификат;
	ИначеЕсли ЭкспортСертификата = Истина Тогда
		Возврат Base64Строка(ТекСертификат.Выгрузить());
	Иначе 
		Возврат Неопределено;
	КонецЕсли;
		
КонецФункции

&НаКлиенте
Функция РасшифроватьЗашифрованныйТокен(ЗашифрованныйТокен, ПарольКонтейнера)
	
	Токен = "";
	
	Попытка
		
		Если ИспользоватьCapicom Тогда
			
			Перекодировщик = Новый COMОбъект("CAPICOM.Utilities");
			ТокенBase64Строка = Base64Строка(ЗашифрованныйТокен);
			ТокенВСтроках = Перекодировщик.Base64Encode(ТокенBase64Строка); //получим токен в строках Base64
			
		Иначе
			
			РасшифрованныеДанные = МенеджерКриптографии1С(ПарольКонтейнера).Расшифровать(ЗашифрованныйТокен);
			ТокенВСтроках = Base64Строка(РасшифрованныеДанные);

		КонецЕсли;
		
		НомерСтроки = 1; //объединим все строки в одну
		ОчереднаяСтрока = СтрПолучитьСтроку(ТокенВСтроках,НомерСтроки);
		Пока ОчереднаяСтрока<>"" Цикл
			Токен = Токен + ОчереднаяСтрока;
			НомерСтроки = НомерСтроки + 1;
			ОчереднаяСтрока = СтрПолучитьСтроку(ТокенВСтроках,НомерСтроки);
		КонецЦикла;
		
	Исключение
		
		_ОписаниеОшибки = ОписаниеОшибки();
		ТекстСообщения = "Не удалось расшифровать токен авторизации в Диадок с помощью <%1> по причине:
							|	" + _ОписаниеОшибки;
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", ?(ИспользоватьCapicom, "Capicom", "Менеджера криптографии 1С"));
		ВызватьИсключение ТекстСообщения;
		
	КонецПопытки;
	
	Возврат Токен;
	
КонецФункции

&НаКлиенте
Функция ХранилищеСертификатовCapicom()
	
	Если ТипЗнч(ХранилищеСертификатов1С) = Тип("COMОбъект") Тогда
		Возврат ХранилищеСертификатов1С;	
	КонецЕсли; 
	
	Попытка
		CAPICOM_MY_STORE = "My";
		CAPICOM_CURRENT_USER_STORE = 2;
		CAPICOM_STORE_OPEN_MAXIMUM_ALLOWED = 2;
		CAPICOM_CERTIFICATE_FIND_SHA1_HASH = 0;
		
		ХранилищеСертификатов1С = Новый COMОбъект("CAPICOM.Store");
		ХранилищеСертификатов1С.Open(CAPICOM_CURRENT_USER_STORE, CAPICOM_MY_STORE, CAPICOM_STORE_OPEN_MAXIMUM_ALLOWED);
	Исключение
		_ОписаниеОшибки = ОписаниеОшибки();
		ТекстСообщения = "Не удалось инициализировать локальное хранилище сертификатов по причине:
							|" + _ОписаниеОшибки + "
							|Следует провести диагностику, перейдя по ссылке: https://help.kontur.ru/ и автоматически установить все предложенные элементы для работы с сертификатами
							|Также можно запустить установку необходимых объектов напрямую, используя: https://help.kontur.ru/content/components/capicom.exe";
		МодульОбъектаКлиент().СообщениеПользователю_КонтурEDI(ТекстСообщения);
	КонецПопытки;
	
	Возврат ХранилищеСертификатов1С;	
		
КонецФункции

&НаКлиенте
Функция ХранилищеСертификатов1С()
	
	Если ХранилищеСертификатов1С <> Неопределено Тогда
		Возврат ХранилищеСертификатов1С;	
	КонецЕсли;
	
	Попытка
		ХранилищеСертификатов1С = МенеджерКриптографии1С().ПолучитьХранилищеСертификатов(ТипХранилищаСертификатовКриптографии.ПерсональныеСертификаты);
	Исключение
		_ОписаниеОшибки = ОписаниеОшибки();
		ТекстСообщения = "Не удалось инициализировать локальное хранилище сертификатов по причине:
							|" + _ОписаниеОшибки;
		МодульОбъектаКлиент().СообщениеПользователю_КонтурEDI(ТекстСообщения);
	КонецПопытки;
	
	Возврат ХранилищеСертификатов1С;	
	
КонецФункции

&НаКлиенте
Функция СоединениеДД()
	
	Если ТипЗнч(СоединениеДД) = Тип("COMОбъект") Тогда
		Возврат СоединениеДД;
	КонецЕсли;
	
	Сервер = ДиадокСерверAPI_Сервер();
	Прокси = Неопределено;
	Порт = 443;
	ЗащищенноеСоединение = Истина;
	
	СоединениеДД = ПолучитьCOMОбъект("","Microsoft.XMLHTTP");
	
	Возврат СоединениеДД;
		
КонецФункции

&НаСервере
Функция ДиадокСерверAPI_Сервер()
	Возврат МодульОбъекта().ДиадокСерверAPI();
КонецФункции

//-------------------------------------------------------------------------------------------------
//вспомогательные методы --------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

&НаКлиенте
Функция ПреобразоватьСтрокуДанныхВДвоичныеДанные(СтрокаДанных)

	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку("<foo xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" 
	|xmlns:xsd=""http://www.w3.org/2001/XMLSchema"" xsi:type=""xsd:hexBinary"">" + СтрокаДанных + "</foo>");
	ДвоичныеДанныеДокумента = СериализаторXDTO.ПрочитатьXML(ЧтениеXML);
	
	Возврат ДвоичныеДанныеДокумента;

КонецФункции // ПреобразоватьСтрокуДанныхВДвоичныеДанные()

&НаКлиенте
Функция РазложитьСтрокуВМассивСлов_КонтурСВ(Знач Строка, РазделителиСлов="")
	
	Слова = Новый Массив;
	
	Для Сч = 1 По СтрДлина(РазделителиСлов) Цикл
		Строка = СтрЗаменить(Строка,Сред(РазделителиСлов,Сч,1),Символы.ПС);
	КонецЦикла;
	
	Для Сч=1 По СтрЧислоСтрок(Строка) Цикл
		ТекСлово = СокрЛП(СтрПолучитьСтроку(Строка,Сч));
		Если ТекСлово<>"" Тогда
			Слова.Добавить(ТекСлово);
		КонецЕсли;	
	КонецЦикла;	
	
	Возврат Слова;
	
КонецФункции

&НаКлиенте
Функция BinaryStream(ПутьКФайлу)
	
	Stream = Новый COMОбъект("ADODB.Stream");
    Stream.Type = 1;
    Stream.Open();
	Stream.LoadFromFile(ПутьКФайлу);
	Возврат Stream.Read();
	
КонецФункции

